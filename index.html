<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Parkour Ultimate</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        .ui-overlay {
            position: absolute;
            pointer-events: none;
            font-family: Arial, sans-serif;
            color: white;
            text-shadow: 2px 2px 2px rgba(0,0,0,0.5);
        }
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
        }
        .menu button {
            padding: 10px 20px;
            margin: 10px;
            font-size: 18px;
            background: #333;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .menu button:hover {
            background: #444;
        }
        .menu h1 {
            color: #ff4444;
            text-shadow: 3px 3px 3px rgba(0,0,0,0.5);
        }
        .menu ul {
            text-align: left;
            margin: 20px;
        }
        .menu li {
            margin: 10px 0;
            color: #ddd;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="uiOverlay" class="ui-overlay"></div>
    <div id="startMenu" class="menu">
        <h1>Stickman Parkour Ultimate</h1>
        <div id="startScreen">
            <button onclick="game.start()">Bắt đầu</button>
            <ul>
                <li>Di chuyển: ← →</li>
                <li>Nhảy: Space</li>
                <li>Wall-run: Cầm Shift khi chạm tường</li>
                <li>Dash: Shift khi đang chạy</li>
                <li>Slide: Ctrl khi đang chạy</li>
                <li>GOD MODE: Tab</li>
            </ul>
        </div>
        <div id="deathScreen" style="display: none;">
            <h2>Game Over!</h2>
            <button onclick="game.revive()">Hồi sinh</button>
            <p>Điểm số: <span id="score">0</span></p>
        </div>
    </div>

    <script>
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.state = {
                    isRunning: false,
                    score: 0,
                    highScore: localStorage.getItem('highScore') || 0
                };
                
                // Khởi tạo các hệ thống
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Khởi tạo các module
                this.player = new Player(this);
                this.map = new MapManager(this);
                this.effects = new EffectSystem(this.ctx);
                this.ui = new UISystem(this);
                
                // Xử lý input
                this.setupInputHandlers();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupInputHandlers() {
                const keys = {};
                window.addEventListener('keydown', (e) => {
                    keys[e.key] = true;
                    this.handleInput(e.key, true);
                });
                window.addEventListener('keyup', (e) => {
                    keys[e.key] = false;
                    this.handleInput(e.key, false);
                });
            }

            handleInput(key, isDown) {
                if (!this.state.isRunning) return;
                
                switch(key) {
                    case ' ':
                        if (isDown) this.player.jump();
                        break;
                    case 'Shift':
                        if (isDown) this.player.startDash();
                        else this.player.stopDash();
                        break;
                    case 'Control':
                        if (isDown) this.player.startSlide();
                        else this.player.stopSlide();
                        break;
                    case 'Tab':
                        this.player.toggleGodMode();
                        break;
                }
            }

            start() {
                document.getElementById('startMenu').style.display = 'none';
                this.state.isRunning = true;
                this.lastTimestamp = performance.now();
                requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            gameLoop(timestamp = 0) {
                const deltaTime = timestamp - this.lastTimestamp;
                this.lastTimestamp = timestamp;

                if (!this.state.isRunning) return;

                this.update(deltaTime);
                this.render();
                requestAnimationFrame((ts) => this.gameLoop(ts));
            }

            update(deltaTime) {
                this.player.update(deltaTime);
                this.map.update(deltaTime);
                this.effects.update(deltaTime);
                this.checkCollisions();
                this.updateScore();
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.map.render(this.ctx);
                this.player.render(this.ctx);
                this.effects.render(this.ctx);
                this.ui.render();
            }

            checkCollisions() {
                const player = this.player;
                const map = this.map;
                
                // Kiểm tra va chạm với death zone
                if (player.y > this.canvas.height - 50) {
                    this.gameOver();
                }
            }

            updateScore() {
                this.state.score += 0.1;
                if (this.state.score > this.state.highScore) {
                    this.state.highScore = this.state.score;
                    localStorage.setItem('highScore', this.state.highScore);
                }
            }

            gameOver() {
                this.state.isRunning = false;
                document.getElementById('startMenu').style.display = 'block';
                document.getElementById('deathScreen').style.display = 'block';
                document.getElementById('score').textContent = Math.floor(this.state.score);
            }

            revive() {
                this.state.score = 0;
                this.player.reset();
                this.start();
            }
        }

        class Player {
            constructor(game) {
                this.game = game;
                this.reset();
                this.size = { width: 30, height: 60 };
                this.states = {
                    isJumping: false,
                    isDashing: false,
                    isSliding: false,
                    isGodMode: false,
                    stamina: 100
                };
            }

            reset() {
                this.position = { x: 100, y: 100 };
                this.velocity = { x: 0, y: 0 };
            }

            update(deltaTime) {
                // Áp dụng trọng lực
                if (!this.states.isGodMode) {
                    this.velocity.y += 0.5;
                }

                // Cập nhật vị trí
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;

                // Giảm stamina khi thực hiện kỹ năng
                if (this.states.isDashing || this.states.isSliding) {
                    this.states.stamina -= 0.5;
                    if (this.states.stamina <= 0) {
                        this.stopAllSkills();
                    }
                } else {
                    this.states.stamina = Math.min(100, this.states.stamina + 0.2);
                }
            }

            render(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                
                // Vẽ nhân vật
                ctx.fillStyle = this.states.isGodMode ? '#ff4444' : '#fff';
                ctx.fillRect(-this.size.width/2, -this.size.height/2, 
                           this.size.width, this.size.height);
                
                // Hiệu ứng trail khi dash
                if (this.states.isDashing) {
                    this.game.effects.createTrail(this.position.x, this.position.y);
                }
                
                ctx.restore();
            }

            jump() {
                if (!this.states.isJumping) {
                    this.velocity.y = -15;
                    this.states.isJumping = true;
                    this.game.effects.createJumpEffect(this.position.x, this.position.y);
                }
            }

            startDash() {
                if (this.states.stamina >= 20) {
                    this.states.isDashing = true;
                    this.velocity.x = 10;
                }
            }

            stopDash() {
                this.states.isDashing = false;
                this.velocity.x = 0;
            }

            startSlide() {
                if (this.states.stamina >= 30) {
                    this.states.isSliding = true;
                    this.velocity.y = 5;
                }
            }

            stopSlide() {
                this.states.isSliding = false;
            }

            toggleGodMode() {
                this.states.isGodMode = !this.states.isGodMode;
            }

// Tiếp tục từ phần trước...

class EffectSystem {
    constructor(ctx) {
        this.ctx = ctx;
        this.particles = [];
        this.trails = [];
    }

    createTrail(x, y) {
        for (let i = 0; i < 5; i++) {
            this.trails.push({
                x: x + Math.random() * 20 - 10,
                y: y + Math.random() * 20 - 10,
                life: 1,
                color: '#ff4444'
            });
        }
    }

    createJumpEffect(x, y) {
        for (let i = 0; i < 10; i++) {
            this.particles.push({
                x: x + Math.random() * 20 - 10,
                y: y + Math.random() * 20 - 10,
                vx: (Math.random() - 0.5) * 5,
                vy: -Math.random() * 5 - 2,
                life: 1,
                color: '#fff'
            });
        }
    }

    update(deltaTime) {
        // Cập nhật particles
        this.particles = this.particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2;
            p.life -= 0.02;
            return p.life > 0;
        });

        // Cập nhật trails
        this.trails = this.trails.filter(t => {
            t.life -= 0.03;
            return t.life > 0;
        });
    }

    render(ctx) {
        // Vẽ particles
        this.particles.forEach(p => {
            ctx.save();
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });

        // Vẽ trails
        this.trails.forEach(t => {
            ctx.save();
            ctx.globalAlpha = t.life;
            ctx.fillStyle = t.color;
            ctx.beginPath();
            ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        });
    }
}

class UISystem {
    constructor(game) {
        this.game = game;
        this.fps = 0;
        this.fpsCounter = 0;
        this.lastFpsUpdate = 0;
    }

    render() {
        const ctx = this.game.ctx;
        const { score, highScore, isRunning } = this.game.state;
        
        // FPS counter
        this.updateFPS();
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.fillText(`FPS: ${this.fps}`, 10, 30);

        // Score và high score
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 50);
        ctx.fillText(`High Score: ${Math.floor(highScore)}`, 10, 70);

        // HUD
        if (isRunning) {
            this.drawHUD();
        }
    }

    updateFPS() {
        const now = performance.now();
        this.fpsCounter++;
        
        if (now - this.lastFpsUpdate >= 1000) {
            this.fps = this.fpsCounter;
            this.fpsCounter = 0;
            this.lastFpsUpdate = now;
        }
    }

    drawHUD() {
        const ctx = this.game.ctx;
        const player = this.game.player;
        
        // Stamina bar
        ctx.fillStyle = '#333';
        ctx.fillRect(10, this.game.canvas.height - 40, 200, 20);
        ctx.fillStyle = player.states.stamina > 30 ? '#4CAF50' : '#f44336';
        ctx.fillRect(10, this.game.canvas.height - 40, 
                    (player.states.stamina / 100) * 200, 20);

        // God mode indicator
        ctx.fillStyle = player.states.isGodMode ? '#ff4444' : '#666';
        ctx.font = '20px Arial';
        ctx.fillText('GOD', this.game.canvas.width - 60, 40);
    }
}

class MapManager {
    constructor(game) {
        this.game = game;
        this.platforms = [];
        this.generateInitialMap();
    }

    generateInitialMap() {
        // Tạo các platform cơ bản
        this.platforms = [
            { x: 0, y: this.game.canvas.height - 50, width: this.game.canvas.width, height: 50 }, // Nền
            { x: 300, y: 400, width: 200, height: 20 }, // Platform 1
            { x: 600, y: 300, width: 200, height: 20 }, // Platform 2
            { x: 900, y: 200, width: 200, height: 20 }  // Platform 3
        ];
    }

    update(deltaTime) {
        // Cập nhật map theo thời gian thực
        this.platforms.forEach(platform => {
            // Thêm hiệu ứng chuyển động cho platform
            platform.x -= 1;
            if (platform.x + platform.width < 0) {
                platform.x = this.game.canvas.width;
            }
        });
    }

    render(ctx) {
        ctx.fillStyle = '#666';
        this.platforms.forEach(platform => {
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        });
    }
}

// Khởi tạo game
const game = new GameEngine();

// Xử lý khi window load
window.onload = () => {
    game.start();
};
       // Tiếp tục từ phần trước...

class AudioManager {
    constructor() {
        this.sounds = {};
        this.music = null;
        this.currentBiome = 'city';
        this.loadSounds();
    }

    loadSounds() {
        // Âm thanh hiệu ứng
        this.sounds = {
            jump: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA'),
            dash: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA'),
            death: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA'),
            powerup: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA')
        };

        // Nhạc nền theo biome
        this.musicTracks = {
            city: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA'),
            desert: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA'),
            lab: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA'),
            forest: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA'),
            hell: new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgA')
        };
    }

    playSound(name) {
        if (this.sounds[name]) {
            this.sounds[name].currentTime = 0;
            this.sounds[name].play();
        }
    }

    playMusic(biome) {
        if (this.currentBiome !== biome) {
            if (this.music) {
                this.music.pause();
            }
            this.music = this.musicTracks[biome];
            this.music.loop = true;
            this.music.play();
            this.currentBiome = biome;
        }
    }
}

class SettingsManager {
    constructor() {
        this.settings = this.loadSettings();
        this.setupSettingsUI();
    }

    loadSettings() {
        const saved = localStorage.getItem('gameSettings');
        return saved ? JSON.parse(saved) : {
            sound: true,
            music: true,
            effects: true,
            fps: 60,
            theme: 'light'
        };
    }

    saveSettings() {
        localStorage.setItem('gameSettings', JSON.stringify(this.settings));
    }

    setupSettingsUI() {
        const settingsDiv = document.createElement('div');
        settingsDiv.id = 'settingsMenu';
        settingsDiv.className = 'menu';
        settingsDiv.style.display = 'none';
        settingsDiv.innerHTML = `
            <h2>Cài đặt</h2>
            <div class="settings-options">
                <label>
                    <input type="checkbox" ${this.settings.sound ? 'checked' : ''} 
                           onchange="settings.toggleSetting('sound')">
                    Âm thanh
                </label>
                <label>
                    <input type="checkbox" ${this.settings.music ? 'checked' : ''} 
                           onchange="settings.toggleSetting('music')">
                    Nhạc nền
                </label>
                <label>
                    <input type="checkbox" ${this.settings.effects ? 'checked' : ''} 
                           onchange="settings.toggleSetting('effects')">
                    Hiệu ứng
                </label>
                <div class="fps-settings">
                    <label>Frame Rate:</label>
                    <select onchange="settings.setFPS(this.value)">
                        <option value="30" ${this.settings.fps === 30 ? 'selected' : ''}>30 FPS</option>
                        <option value="60" ${this.settings.fps === 60 ? 'selected' : ''}>60 FPS</option>
                        <option value="120" ${this.settings.fps === 120 ? 'selected' : ''}>120 FPS</option>
                    </select>
                </div>
                <div class="theme-settings">
                    <label>Giao diện:</label>
                    <select onchange="settings.setTheme(this.value)">
                        <option value="light" ${this.settings.theme === 'light' ? 'selected' : ''}>Sáng</option>
                        <option value="dark" ${this.settings.theme === 'dark' ? 'selected' : ''}>Tối</option>
                    </select>
                </div>
            </div>
            <button onclick="settings.hide()">Đóng</button>
        `;
        document.body.appendChild(settingsDiv);
    }

    toggleSetting(key) {
        this.settings[key] = !this.settings[key];
        this.saveSettings();
        this.applySettings();
    }

    setFPS(value) {
        this.settings.fps = parseInt(value);
        this.saveSettings();
        this.applySettings();
    }

    setTheme(theme) {
        this.settings.theme = theme;
        this.saveSettings();
        this.applySettings();
    }

    applySettings() {
        // Áp dụng các cài đặt
        document.body.className = this.settings.theme;
        
        // Cập nhật FPS target
        game.targetFPS = this.settings.fps;
    }

    show() {
        document.getElementById('settingsMenu').style.display = 'block';
    }

    hide() {
        document.getElementById('settingsMenu').style.display = 'none';
    }
}

// Cập nhật GameEngine để hỗ trợ các tính năng mới
class GameEngine {
    constructor()
   // Tiếp tục từ phần trước...

class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.audioManager = new AudioManager();
        this.settings = new SettingsManager();
        this.biomes = new BiomeManager(this);
        this.enemies = new EnemyManager(this);
        this.checkpoints = new CheckpointManager(this);
        
        // Thêm nút settings vào menu
        const startScreen = document.getElementById('startScreen');
        const settingsButton = document.createElement('button');
        settingsButton.textContent = 'Cài đặt';
        settingsButton.onclick = () => this.settings.show();
        startScreen.appendChild(settingsButton);
    }

    start() {
        // Các lệnh đã có từ trước...
        this.biomes.start();
        this.enemies.start();
        this.checkpoints.start();
        this.audioManager.playMusic('city');
    }

    update(deltaTime) {
        // Các cập nhật đã có từ trước...
        this.biomes.update(deltaTime);
        this.enemies.update(deltaTime);
        this.checkpoints.update(deltaTime);
        
        // Kiểm tra va chạm với enemies
        this.enemies.checkCollisions(this.player);
        
        // Kiểm tra checkpoint
        this.checkpoints.check(this.player);
    }
}

class BiomeManager {
    constructor(game) {
        this.game = game;
        this.currentBiome = 'city';
        this.biomeTransition = 0;
        this.biomes = {
            city: { color: '#00ffff', music: 'city' },
            desert: { color: '#ff9900', music: 'desert' },
            lab: { color: '#ff00ff', music: 'lab' },
            forest: { color: '#00ff00', music: 'forest' },
            hell: { color: '#ff0000', music: 'hell' }
        };
    }

    update(deltaTime) {
        // Chuyển đổi biome theo điểm số
        const score = this.game.state.score;
        if (score < 1000) this.currentBiome = 'city';
        else if (score < 2000) this.currentBiome = 'desert';
        else if (score < 3000) this.currentBiome = 'lab';
        else if (score < 4000) this.currentBiome = 'forest';
        else this.currentBiome = 'hell';

        // Hiệu ứng chuyển đổi biome
        this.biomeTransition += deltaTime * 0.001;
        if (this.biomeTransition > 1) {
            this.biomeTransition = 0;
            this.game.audioManager.playMusic(this.currentBiome);
        }
    }

    render(ctx) {
        const biome = this.biomes[this.currentBiome];
        ctx.fillStyle = biome.color;
        ctx.globalAlpha = 0.1;
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.globalAlpha = 1;
    }
}

class EnemyManager {
    constructor(game) {
        this.game = game;
        this.enemies = [];
        this.spawnTimer = 0;
    }

    start() {
        this.spawnTimer = 0;
    }

    update(deltaTime) {
        this.spawnTimer += deltaTime;
        if (this.spawnTimer > 2000) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }

        // Cập nhật enemies
        this.enemies = this.enemies.filter(enemy => {
            enemy.update(deltaTime);
            return enemy.isActive();
        });
    }

    spawnEnemy() {
        const types = ['normal', 'flying', 'shooting'];
        const type = types[Math.floor(Math.random() * types.length)];
        const enemy = new Enemy(this.game.canvas.width, type);
        this.enemies.push(enemy);
    }

    checkCollisions(player) {
        this.enemies.forEach(enemy => {
            if (enemy.checkCollision(player) && !player.states.isGodMode) {
                this.game.gameOver();
            }
        });
    }
}

class Enemy {
    constructor(x, type) {
        this.x = x;
        this.y = Math.random() * 400;
        this.type = type;
        this.speed = 2;
        this.bullets = [];
    }

    update(deltaTime) {
        this.x -= this.speed;
        
        if (this.type === 'shooting') {
            if (Math.random() < 0.02) {
                this.shoot();
            }
        }
    }

    shoot() {
        this.bullets.push(new Bullet(this.x, this.y));
    }

    checkCollision(player) {
        const dx = Math.abs(this.x - player.position.x);
        const dy = Math.abs(this.y - player.position.y);
        return dx < 30 && dy < 30;
    }

    isActive() {
        return this.x + 30 > 0;
    }

    render(ctx) {
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(this.x, this.y, 30, 30);
        
        this.bullets.forEach(bullet => bullet.render(ctx));
        this.bullets = this.bullets.filter(bullet => bullet.isActive());
    }
}

class Bullet {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.speed = 5;
    }

    render(ctx) {
        ctx.fillStyle = '#ff4444';
        ctx.fillRect(this.x, this.y, 10, 10);
        this.x -= this.speed;
    }

    isActive() {
        return this.x + 10 > 0;
    }
}

class CheckpointManager {
    constructor(game) {
        this.game = game;
        this.checkpoints = [];
        this.lastCheckpoint = null;
        this.generateCheckpoints();
    }

    generateCheckpoints() {
        for (let i = 0; i < 5; i++) {
            this.checkpoints.push({
                x: i * 1000,
                y: Math.random() * 300,
                passed: false
            });
        }
    }

    check(player) {
        this.checkpoints.forEach(checkpoint => {
            if (!checkpoint.passed && 
                player.position.x > checkpoint.x && 
                player.position.x - checkpoint.x < 50) {
                checkpoint.passed = true;
                this.game.audioManager.playSound('powerup');
                this.game.state.score += 500;
            }
        });
    }

    render(ctx) {
        this.checkpoints.forEach(checkpoint => {
            ctx.fillStyle = checkpoint.passed ? '#00ff00' : '#ffff00';
            ctx.beginPath();
            ctx.arc(checkpoint.x, checkpoint.y, 20, 0, Math.PI * 2);
            ctx.fill();
        });
    }
}

// Khởi tạo game
const game = new GameEngine();
const settings = new SettingsManager();

// Thêm các hàm toàn cục cho UI
window.settings = settings;
window.game = game;

// Xử lý khi window load
window.onload = () => {
    game.start();
};
       // Thêm vào phần CSS trong thẻ <style>
.menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #fff;
    z-index: 1000;
}

#settingsMenu {
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.settings-options {
    display: grid;
    gap: 15px;
    margin: 20px 0;
}

.fps-settings, .theme-settings {
    margin-top: 10px;
}

.fps-settings select, .theme-settings select {
    margin-left: 10px;
    padding: 5px;
    border-radius: 5px;
}

// Thêm vào phần JavaScript
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
    }

    gameLoop(timestamp = 0) {
        // Tối ưu hiệu năng với frame rate target
        const deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;

        if (deltaTime < this.frameInterval) {
            requestAnimationFrame((ts) => this.gameLoop(ts));
            return;
        }

        // Cập nhật và render như trước
        this.update(deltaTime);
        this.render();
        requestAnimationFrame((ts) => this.gameLoop(ts));
    }
}

// Thêm vào phần HTML
<div id="pauseMenu" class="menu" style="display: none;">
    <h2>Tạm dừng</h2>
    <button onclick="game.resume()">Tiếp tục</button>
    <button onclick="settings.show()">Cài đặt</button>
    <button onclick="game.restart()">Chơi lại</button>
</div>

// Thêm vào phần JavaScript
class Player {
    constructor(game) {
        // Các thuộc tính đã có từ trước...
        this.lastGroundedTime = 0;
        this.perfectJumpWindow = 100; // 100ms window cho perfect jump
    }

    handleParkour(deltaTime) {
        // Kiểm tra perfect jump
        if (this.velocity.y > 0 && 
            this.isOnGround() && 
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow) {
            this.game.audioManager.playSound('powerup');
            this.game.state.score += 1000;
        }

        // Cập nhật last grounded time
        if (this.isOnGround()) {
            this.lastGroundedTime = performance.now();
        }
    }

    isOnGround() {
        return this.velocity.y === 0 && this.position.y === this.game.canvas.height - 50 - this.size.height;
    }
}

// Thêm vào class GameEngine
resume() {
    document.getElementById('pauseMenu').style.display = 'none';
    this.state.isRunning = true;
    this.lastTimestamp = performance.now();
    requestAnimationFrame((ts) => this.gameLoop(ts));
}

restart() {
    document.getElementById('pauseMenu').style.display = 'none';
    this.state = {
        isRunning: true,
        score: 0,
        highScore: localStorage.getItem('highScore') || 0
    };
    this.player.reset();
    this.biomes.reset();
    this.enemies.reset();
    this.checkpoints.reset();
    this.lastTimestamp = performance.now();
    requestAnimationFrame((ts) => this.gameLoop(ts));
}

// Thêm vào class SettingsManager
applySettings() {
    // Các lệnh đã có từ trước...
    document.body.className = this.settings.theme;
    
    // Áp dụng frame rate target
    game.targetFPS = this.settings.fps;
    
    // Áp dụng hiệu ứng
    game.effects.enabled = this.settings.effects;
    
    // Áp dụng âm thanh
    if (this.settings.sound) {
        game.audioManager.playSound('powerup');
    }
    if (this.settings.music) {
        game.audioManager.playMusic(game.biomes.currentBiome);
    }
}
       // Thêm vào phần CSS
.menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #fff;
    z-index: 1000;
}

#settingsMenu {
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.settings-options {
    display: grid;
    gap: 15px;
    margin: 20px 0;
}

.fps-settings, .theme-settings {
    margin-top: 10px;
}

.fps-settings select, .theme-settings select {
    margin-left: 10px;
    padding: 5px;
    border-radius: 5px;
}

// Thêm vào phần JavaScript
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
        this.objectPool = new ObjectPool();
    }

    gameLoop(timestamp = 0) {
        // Tối ưu hiệu năng với frame rate target
        const deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;

        if (deltaTime < this.frameInterval) {
            requestAnimationFrame((ts) => this.gameLoop(ts));
            return;
        }

        // Cập nhật và render như trước
        this.update(deltaTime);
        this.render();
        requestAnimationFrame((ts) => this.gameLoop(ts));
    }
}

class ObjectPool {
    constructor() {
        this.pools = {};
    }

    createPool(type, size, factory) {
        this.pools[type] = {
            objects: Array(size).fill().map(() => factory()),
            size: size,
            factory: factory
        };
    }

    get(type) {
        const pool = this.pools[type];
        if (!pool) return pool.factory();
        
        for (let i = 0; i < pool.objects.length; i++) {
            if (!pool.objects[i].active) {
                pool.objects[i].reset();
                return pool.objects[i];
            }
        }
        
        // Tăng kích thước pool nếu cần
        const newObj = pool.factory();
        pool.objects.push(newObj);
        pool.size++;
        return newObj;
    }

    returnToPool(type, object) {
        const pool = this.pools[type];
        if (pool) {
            object.active = false;
        }
    }
}

// Thêm vào class Player
class Player {
    constructor(game) {
        // Các thuộc tính đã có từ trước...
        this.lastGroundedTime = 0;
        this.perfectJumpWindow = 100; // 100ms window cho perfect jump
        this.wallSlideVelocity = 2; // Tốc độ trượt tường
        this.wallJumpForce = 15; // Lực nhảy tường
        this.climbSpeed = 5; // Tốc độ leo tường
    }

    handleParkour(deltaTime) {
        // Kiểm tra perfect jump
        if (this.velocity.y > 0 && 
            this.isOnGround() && 
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow) {
            this.game.audioManager.playSound('powerup');
            this.game.state.score += 1000;
        }

        // Xử lý wall slide và climb
        if (this.isAgainstWall()) {
            if (this.states.isWallRunning) {
                this.velocity.y = Math.min(this.velocity.y + 0.5, this.wallSlideVelocity);
            } else if (this.states.isClimbing) {
                this.velocity.y = -this.climbSpeed;
            }
        }

        // Cập nhật last grounded time
        if (this.isOnGround()) {
            this.lastGroundedTime = performance.now();
        }
    }

    isOnGround() {
        return this.velocity.y === 0 && 
               this.position.y === this.game.canvas.height - 50 - this.size.height;
    }

    isAgainstWall() {
        return this.position.x <= 0 || 
               this.position.x + this.size.width >= this.game.canvas.width;
    }

    wallJump() {
        if (this.isAgainstWall() && this.states.isWallRunning) {
            this.velocity.x = this.position.x <= 0 ? 10 : -10;
            this.velocity.y = -this.wallJumpForce;
            this.states.isWallRunning = false;
            this.game.audioManager.playSound('jump');
        }
    }
}

// Thêm vào class EnemyManager
class EnemyManager {
    constructor(game) {
        this.game = game;
        this.enemies = [];
        this.spawnTimer = 0;
        this.difficulty = 1;
    }

    update(deltaTime) {
        this.spawnTimer += deltaTime;
        if (this.spawnTimer > 2000 / this.difficulty) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }

        // Cập nhật enemies với object pooling
        this.enemies = this.enemies.filter(enemy => {
            enemy.update(deltaTime);
            if (!enemy.isActive()) {
                game.objectPool.returnToPool('enemy', enemy);
            }
            return enemy.isActive();
        });
    }

    spawnEnemy() {
        const types = ['normal', 'flying', 'shooting'];
        const type = types[Math.floor(Math.random() * types.length)];
        const enemy = game.objectPool.get('enemy');
        enemy.init(type, this.game.canvas.width, 
                  Math.random() * 400, this.difficulty);
        this.enemies.push(enemy);
    }

    increaseDifficulty() {
        this.difficulty = Math.min(3, this.difficulty + 0.5);
    }
}

// Thêm vào class BiomeManager
class BiomeManager {
    constructor(game) {
        this.game = game;
        this.currentBiome = 'city';
        this.biomeTransition = 0;
        this.biomes = {
            city: { color: '#00ffff', music: 'city', difficulty: 1 },
            desert: { color: '#ff9900', music: 'desert', difficulty: 1.5 },
            lab: { color: '#ff00ff', music: 'lab', difficulty: 2 },
            forest: { color: '#00ff00', music: 'forest', difficulty: 2.5 },
            hell: { color: '#ff0000', music: 'hell', difficulty: 3 }
        };
    }

    update(deltaTime) {
        // Chuyển đổi biome theo điểm số
        const score = this.game.state.score;
        if (score < 1000) this.currentBiome = 'city';
        else if (score < 2000) this.currentBiome = 'desert';
        else if (score < 3000) this.currentBiome = 'lab';
        else if (score < 4000) this.currentBiome = 'forest';
        else this.currentBiome = 'hell';

        // Hiệu ứng chuyển đổi biome
        this.biomeTransition += deltaTime * 0.001;
        if (this.biomeTransition > 1) {
            this.biomeTransition = 0;
            this.game.audioManager.playMusic(this.currentBiome);
            this.game.enemyManager.increaseDifficulty();
        }
    }
}

// Khởi tạo object pool
game.objectPool.createPool('enemy', 20, () => new Enemy(game.canvas.width, 'normal'));
game.objectPool.createPool('bullet', 50, () => new Bullet(0, 0));

// Thêm vào class GameEngine
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
        this.objectPool = new ObjectPool();
        this.memoryUsage = 0;
        this.lastGC = 0;
    }

    update(deltaTime) {
        // Các cập nhật đã có từ trước...
        
        // Quản lý bộ nhớ
        this.memoryUsage += deltaTime;
        if (this.memoryUsage > 5000) { // 5 giây
            this.cleanup();
            this.memoryUsage = 0;
        }
    }

    cleanup() {
        // Dọn dẹp các objects không sử dụng
        this.objectPool.cleanup();
        
        // Xóa các particles cũ
        this.effects.cleanup();
        
        // Giảm bộ nhớ canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}
       // Thêm vào phần CSS
.menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    color: #fff;
    z-index: 1000;
}

#settingsMenu {
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.settings-options {
    display: grid;
    gap: 15px;
    margin: 20px 0;
}

.fps-settings, .theme-settings {
    margin-top: 10px;
}

.fps-settings select, .theme-settings select {
    margin-left: 10px;
    padding: 5px;
    border-radius: 5px;
}

// Thêm vào phần JavaScript
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
        this.objectPool = new ObjectPool();
    }

    gameLoop(timestamp = 0) {
        // Tối ưu hiệu năng với frame rate target
        const deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;

        if (deltaTime < this.frameInterval) {
            requestAnimationFrame((ts) => this.gameLoop(ts));
            return;
        }

        // Cập nhật và render như trước
        this.update(deltaTime);
        this.render();
        requestAnimationFrame((ts) => this.gameLoop(ts));
    }
}

class ObjectPool {
    constructor() {
        this.pools = {};
    }

    createPool(type, size, factory) {
        this.pools[type] = {
            objects: Array(size).fill().map(() => factory()),
            size: size,
            factory: factory
        };
    }

    get(type) {
        const pool = this.pools[type];
        if (!pool) return pool.factory();
        
        for (let i = 0; i < pool.objects.length; i++) {
            if (!pool.objects[i].active) {
                pool.objects[i].reset();
                return pool.objects[i];
            }
        }
        
        // Tăng kích thước pool nếu cần
        const newObj = pool.factory();
        pool.objects.push(newObj);
        pool.size++;
        return newObj;
    }

    returnToPool(type, object) {
        const pool = this.pools[type];
        if (pool) {
            object.active = false;
        }
    }
}

// Thêm vào class Player
class Player {
    constructor(game) {
        // Các thuộc tính đã có từ trước...
        this.lastGroundedTime = 0;
        this.perfectJumpWindow = 100; // 100ms window cho perfect jump
        this.wallSlideVelocity = 2; // Tốc độ trượt tường
        this.wallJumpForce = 15; // Lực nhảy tường
        this.climbSpeed = 5; // Tốc độ leo tường
    }

    handleParkour(deltaTime) {
        // Kiểm tra perfect jump
        if (this.velocity.y > 0 && 
            this.isOnGround() && 
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow) {
            this.game.audioManager.playSound('powerup');
            this.game.state.score += 1000;
        }

        // Xử lý wall slide và climb
        if (this.isAgainstWall()) {
            if (this.states.isWallRunning) {
                this.velocity.y = Math.min(this.velocity.y + 0.5, this.wallSlideVelocity);
            } else if (this.states.isClimbing) {
                this.velocity.y = -this.climbSpeed;
            }
        }

        // Cập nhật last grounded time
        if (this.isOnGround()) {
            this.lastGroundedTime = performance.now();
        }
    }

    isOnGround() {
        return this.velocity.y === 0 && 
               this.position.y === this.game.canvas.height - 50 - this.size.height;
    }

    isAgainstWall() {
        return this.position.x <= 0 || 
               this.position.x + this.size.width >= this.game.canvas.width;
    }

    wallJump() {
        if (this.isAgainstWall() && this.states.isWallRunning) {
            this.velocity.x = this.position.x <= 0 ? 10 : -10;
            this.velocity.y = -this.wallJumpForce;
            this.states.isWallRunning = false;
            this.game.audioManager.playSound('jump');
        }
    }
}

// Thêm vào class EnemyManager
class EnemyManager {
    constructor(game) {
        this.game = game;
        this.enemies = [];
        this.spawnTimer = 0;
        this.difficulty = 1;
    }

    update(deltaTime) {
        this.spawnTimer += deltaTime;
        if (this.spawnTimer > 2000 / this.difficulty) {
            this.spawnEnemy();
            this.spawnTimer = 0;
        }

        // Cập nhật enemies với object pooling
        this.enemies = this.enemies.filter(enemy => {
            enemy.update(deltaTime);
            if (!enemy.isActive()) {
                game.objectPool.returnToPool('enemy', enemy);
            }
            return enemy.isActive();
        });
    }

    spawnEnemy() {
        const types = ['normal', 'flying', 'shooting'];
        const type = types[Math.floor(Math.random() * types.length)];
        const enemy = game.objectPool.get('enemy');
        enemy.init(type, this.game.canvas.width, 
                  Math.random() * 400, this.difficulty);
        this.enemies.push(enemy);
    }

    increaseDifficulty() {
        this.difficulty = Math.min(3, this.difficulty + 0.5);
    }
}

// Thêm vào class BiomeManager
class BiomeManager {
    constructor(game) {
        this.game = game;
        this.currentBiome = 'city';
        this.biomeTransition = 0;
        this.biomes = {
            city: { color: '#00ffff', music: 'city', difficulty: 1 },
            desert: { color: '#ff9900', music: 'desert', difficulty: 1.5 },
            lab: { color: '#ff00ff', music: 'lab', difficulty: 2 },
            forest: { color: '#00ff00', music: 'forest', difficulty: 2.5 },
            hell: { color: '#ff0000', music: 'hell', difficulty: 3 }
        };
    }

    update(deltaTime) {
        // Chuyển đổi biome theo điểm số
        const score = this.game.state.score;
        if (score < 1000) this.currentBiome = 'city';
        else if (score < 2000) this.currentBiome = 'desert';
        else if (score < 3000) this.currentBiome = 'lab';
        else if (score < 4000) this.currentBiome = 'forest';
        else this.currentBiome = 'hell';

        // Hiệu ứng chuyển đổi
   // Thêm vào class BiomeManager
class BiomeManager {
    constructor(game) {
        this.game = game;
        this.currentBiome = 'city';
        this.biomeTransition = 0;
        this.biomes = {
            city: { color: '#00ffff', music: 'city', difficulty: 1 },
            desert: { color: '#ff9900', music: 'desert', difficulty: 1.5 },
            lab: { color: '#ff00ff', music: 'lab', difficulty: 2 },
            forest: { color: '#00ff00', music: 'forest', difficulty: 2.5 },
            hell: { color: '#ff0000', music: 'hell', difficulty: 3 }
        };
    }

    update(deltaTime) {
        // Chuyển đổi biome theo điểm số
        const score = this.game.state.score;
        if (score < 1000) this.currentBiome = 'city';
        else if (score < 2000) this.currentBiome = 'desert';
        else if (score < 3000) this.currentBiome = 'lab';
        else if (score < 4000) this.currentBiome = 'forest';
        else this.currentBiome = 'hell';

        // Hiệu ứng chuyển đổi biome
        this.biomeTransition += deltaTime * 0.001;
        if (this.biomeTransition > 1) {
            this.biomeTransition = 0;
            this.game.audioManager.playMusic(this.currentBiome);
            this.game.enemyManager.increaseDifficulty();
        }
    }

    render(ctx) {
        const biome = this.biomes[this.currentBiome];
        ctx.fillStyle = biome.color;
        ctx.globalAlpha = 0.1;
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.globalAlpha = 1;
    }
}

// Thêm vào class GameEngine
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
        this.objectPool = new ObjectPool();
        this.memoryUsage = 0;
        this.lastGC = 0;
    }

    update(deltaTime) {
        // Các cập nhật đã có từ trước...
        
        // Quản lý bộ nhớ
        this.memoryUsage += deltaTime;
        if (this.memoryUsage > 5000) { // 5 giây
            this.cleanup();
            this.memoryUsage = 0;
        }
    }

    cleanup() {
        // Dọn dẹp các objects không sử dụng
        this.objectPool.cleanup();
        
        // Xóa các particles cũ
        this.effects.cleanup();
        
        // Giảm bộ nhớ canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Thêm class AchievementManager
class AchievementManager {
    constructor(game) {
        this.game = game;
        this.achievements = {
            perfectJump: {
                name: 'Nhảy Hoàn Hảo',
                description: 'Thực hiện 10 perfect jump',
                count: 0,
                unlocked: false,
                reward: 1000
            },
            wallMaster: {
                name: 'Chúa Tường',
                description: 'Leo tường 50 lần',
                count: 0,
                unlocked: false,
                reward: 2000
            },
            biomeExplorer: {
                name: 'Nhà Khám Phá',
                description: 'Khám phá tất cả các biome',
                unlocked: false,
                reward: 5000
            }
        };
    }

    checkAchievements() {
        // Kiểm tra perfect jump achievement
        if (this.game.player.perfectJumps >= 10 && !this.achievements.perfectJump.unlocked) {
            this.unlockAchievement('perfectJump');
        }

        // Kiểm tra wall master achievement
        if (this.game.player.wallClimbs >= 50 && !this.achievements.wallMaster.unlocked) {
            this.unlockAchievement('wallMaster');
        }

        // Kiểm tra biome explorer achievement
        const visitedBiomes = new Set(this.game.biomeManager.visitedBiomes);
        if (visitedBiomes.size === 5 && !this.achievements.biomeExplorer.unlocked) {
            this.unlockAchievement('biomeExplorer');
        }
    }

    unlockAchievement(id) {
        const achievement = this.achievements[id];
        achievement.unlocked = true;
        this.game.state.score += achievement.reward;
        this.game.audioManager.playSound('powerup');
        this.showAchievementNotification(achievement);
    }

    showAchievementNotification(achievement) {
        const notification = document.createElement('div');
        notification.className = 'achievement-notification';
        notification.innerHTML = `
            <h3>Mới Mở Khóa!</h3>
            <p><strong>${achievement.name}</strong></p>
            <p>${achievement.description}</p>
            <p>+${achievement.reward} điểm</p>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
}

// Thêm vào class Player
class Player {
    constructor(game) {
        // Các thuộc tính đã có từ trước...
        this.perfectJumps = 0;
        this.wallClimbs = 0;
        this.comboMultiplier = 1;
        this.lastComboTime = 0;
        this.comboWindow = 2000; // 2 giây để duy trì combo
    }

    handleParkour(deltaTime) {
        // Kiểm tra perfect jump
        if (this.velocity.y > 0 && 
            this.isOnGround() && 
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow) {
            this.perfectJumps++;
            this.game.state.score += 1000 * this.comboMultiplier;
            this.game.audioManager.playSound('powerup');
            this.updateCombo();
        }

        // Xử lý wall slide và climb
        if (this.isAgainstWall()) {
            if (this.states.isWallRunning) {
                this.velocity.y = Math.min(this.velocity.y + 0.5, this.wallSlideVelocity);
            } else if (this.states.isClimbing) {
                this.wallClimbs++;
                this.velocity.y = -this.climbSpeed;
            }
        }

        // Cập nhật combo
        if (performance.now() - this.lastComboTime > this.comboWindow) {
            this.comboMultiplier = 1;
        }
    }

    updateCombo() {
        this.lastComboTime = performance.now();
        this.comboMultiplier = Math.min(5, this.comboMultiplier + 0.5);
    }
}

// Thêm vào class UISystem
class UISystem {
    constructor(game) {
        this.game = game;
        this.fps = 0;
        this.fpsCounter = 0;
        this.lastFpsUpdate = 0;
        this.comboTimer = 0;
    }

    render() {
        const ctx = this.game.ctx;
        const { score, highScore, isRunning } = this.game.state;
        
        // FPS counter
        this.updateFPS();
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.fillText(`FPS: ${this.fps}`, 10, 30);

        // Score và high score
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 50);
        ctx.fillText(`High Score: ${Math.floor(highScore)}`, 10, 70);

        // Combo multiplier
        if (this.game.player.comboMultiplier > 1) {
            this.comboTimer += 1;
            ctx.fillStyle = '#ff4444';
            ctx.font = '24px Arial';
            ctx.fillText(`COMBO x${this.game.player.comboMultiplier.toFixed(1)}`, 
                        this.game.canvas.width - 150, 40);
            
            if (this.comboTimer > 60) {
                this.comboTimer = 0;
            }
        }

        // Achievement notifications
        this.renderAchievementNotifications();
    }

    renderAchievementNotifications() {
        const notifications = document.querySelectorAll('.achievement-notification');
        notifications.forEach(notification => {
            const rect = notification.getBoundingClientRect();
            this.game.ctx.save();
            this.game.ctx.fillStyle = '#00000088';
            this.game.ctx.fillRect(rect.left, rect.top, 
                                rect.width, rect.height);
            this.game.ctx.restore();
        });
    }
}

// Thêm vào class GameEngine
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.achievementManager = new AchievementManager(this);
    }

    update(deltaTime) {
        // Các cập nhật đã có từ trước...
        this.achievementManager.checkAchievements();
    }
}
       // Thêm vào class GameEngine
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
        this.objectPool = new ObjectPool();
        this.memoryUsage = 0;
        this.lastGC = 0;
    }

    update(deltaTime) {
        // Các cập nhật đã có từ trước...
        
        // Quản lý bộ nhớ
        this.memoryUsage += deltaTime;
        if (this.memoryUsage > 5000) { // 5 giây
            this.cleanup();
            this.memoryUsage = 0;
        }
    }

    cleanup() {
        // Dọn dẹp các objects không sử dụng
        this.objectPool.cleanup();
        
        // Xóa các particles cũ
        this.effects.cleanup();
        
        // Giảm bộ nhớ canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Thêm vào class BiomeManager
class BiomeManager {
    constructor(game) {
        this.game = game;
        this.currentBiome = 'city';
        this.biomeTransition = 0;
        this.biomes = {
            city: { color: '#00ffff', music: 'city', difficulty: 1 },
            desert: { color: '#ff9900', music: 'desert', difficulty: 1.5 },
            lab: { color: '#ff00ff', music: 'lab', difficulty: 2 },
            forest: { color: '#00ff00', music: 'forest', difficulty: 2.5 },
            hell: { color: '#ff0000', music: 'hell', difficulty: 3 }
        };
        this.visitedBiomes = new Set();
    }

    update(deltaTime) {
        // Chuyển đổi biome theo điểm số
        const score = this.game.state.score;
        if (score < 1000) this.currentBiome = 'city';
        else if (score < 2000) this.currentBiome = 'desert';
        else if (score < 3000) this.currentBiome = 'lab';
        else if (score < 4000) this.currentBiome = 'forest';
        else this.currentBiome = 'hell';

        // Thêm biome vào danh sách đã thăm
        this.visitedBiomes.add(this.currentBiome);

        // Hiệu ứng chuyển đổi biome
        this.biomeTransition += deltaTime * 0.001;
        if (this.biomeTransition > 1) {
            this.biomeTransition = 0;
            this.game.audioManager.playMusic(this.currentBiome);
            this.game.enemyManager.increaseDifficulty();
        }
    }

    render(ctx) {
        const biome = this.biomes[this.currentBiome];
        ctx.fillStyle = biome.color;
        ctx.globalAlpha = 0.1;
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.globalAlpha = 1;
    }
}

// Thêm vào class Player
class Player {
    constructor(game) {
        // Các thuộc tính đã có từ trước...
        this.perfectJumps = 0;
        this.wallClimbs = 0;
        this.comboMultiplier = 1;
        this.lastComboTime = 0;
        this.comboWindow = 2000; // 2 giây để duy trì combo
    }

    handleParkour(deltaTime) {
        // Kiểm tra perfect jump
        if (this.velocity.y > 0 && 
            this.isOnGround() && 
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow) {
            this.perfectJumps++;
            this.game.state.score += 1000 * this.comboMultiplier;
            this.game.audioManager.playSound('powerup');
            this.updateCombo();
        }

        // Xử lý wall slide và climb
        if (this.isAgainstWall()) {
            if (this.states.isWallRunning) {
                this.velocity.y = Math.min(this.velocity.y + 0.5, this.wallSlideVelocity);
            } else if (this.states.isClimbing) {
                this.wallClimbs++;
                this.velocity.y = -this.climbSpeed;
            }
        }

        // Cập nhật combo
        if (performance.now() - this.lastComboTime > this.comboWindow) {
            this.comboMultiplier = 1;
        }
    }

    updateCombo() {
        this.lastComboTime = performance.now();
        this.comboMultiplier = Math.min(5, this.comboMultiplier + 0.5);
    }
}

// Thêm vào class UISystem
class UISystem {
    constructor(game) {
        this.game = game;
        this.fps = 0;
        this.fpsCounter = 0;
        this.lastFpsUpdate = 0;
        this.comboTimer = 0;
    }

    render() {
        const ctx = this.game.ctx;
        const { score, highScore, isRunning } = this.game.state;
        
        // FPS counter
        this.updateFPS();
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.fillText(`FPS: ${this.fps}`, 10, 30);

        // Score và high score
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 50);
        ctx.fillText(`High Score: ${Math.floor(highScore)}`, 10, 70);

        // Combo multiplier
        if (this.game.player.comboMultiplier > 1) {
            this.comboTimer += 1;
            ctx.fillStyle = '#ff4444';
            ctx.font = '24px Arial';
            ctx.fillText(`COMBO x${this.game.player.comboMultiplier.toFixed(1)}`, 
                        this.game.canvas.width - 150, 40);
            
            if (this.comboTimer > 60) {
                this.comboTimer = 0;
            }
        }

        // Achievement notifications
        this.renderAchievementNotifications();
    }

    renderAchievementNotifications() {
        const notifications = document.querySelectorAll('.achievement-notification');
        notifications.forEach(notification => {
            const rect = notification.getBoundingClientRect();
            this.game.ctx.save();
            this.game.ctx.fillStyle = '#00000088';
            this.game.ctx.fillRect(rect.left, rect.top, 
                                rect.width, rect.height);
            this.game.ctx.restore();
        });
    }
}

// Thêm vào class AchievementManager
class AchievementManager {
    constructor(game) {
        this.game = game;
        this.achievements = {
            perfectJump: {
                name: 'Nhảy Hoàn Hảo',
                description: 'Thực hiện 10 perfect jump',
                count: 0,
                unlocked: false,
                reward: 1000
            },
            wallMaster: {
                name: 'Chúa Tường',
                description: 'Leo tường 50 lần',
                count: 0,
                unlocked: false,
                reward: 2000
            },
            biomeExplorer: {
                name: 'Nhà Khám Phá',
                description: 'Khám phá tất cả các biome',
                unlocked: false,
                reward: 5000
            }
        };
    }

    checkAchievements() {
        // Kiểm tra perfect jump achievement
        if (this.game.player.perfectJumps >= 10 && !this.achievements.perfectJump.unlocked) {
            this.unlockAchievement('perfectJump');
        }

        // Kiểm tra wall master achievement
        if (this.game.player.wallClimbs >= 50 && !this.achievements.wallMaster.unlocked) {
            this.unlockAchievement('wallMaster');
        }

        // Kiểm tra biome explorer achievement
        const visitedBiomes = new Set(this.game.biomeManager.visitedBiomes);
        if (visitedBiomes.size === 5 && !this.achievements.biomeExplorer.unlocked) {
            this.unlockAchievement('biomeExplorer');
        }
    }

    unlockAchievement(id) {
        const achievement = this.achievements[id];
        achievement.unlocked = true;
        this.game.state.score += achievement.reward;
        this.game.audioManager.playSound('powerup');
        this.showAchievementNotification(achievement);
    }

    showAchievementNotification(achievement) {
        const notification = document.createElement('div');
        notification.className = 'achievement-notification';
        notification.innerHTML = `
            <h3>Mới Mở Khóa!</h3>
            <p><strong>${achievement.name}</strong></p>
            <p>${achievement.description}</p>
            <p>+${achievement.reward} điểm</p>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
}
       // Thêm vào class GameEngine
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
        this.objectPool = new ObjectPool();
        this.memoryUsage = 0;
        this.lastGC = 0;
    }

    update(deltaTime) {
        // Các cập nhật đã có từ trước...
        
        // Quản lý bộ nhớ
        this.memoryUsage += deltaTime;
        if (this.memoryUsage > 5000) { // 5 giây
            this.cleanup();
            this.memoryUsage = 0;
        }
    }

    cleanup() {
        // Dọn dẹp các objects không sử dụng
        this.objectPool.cleanup();
        
        // Xóa các particles cũ
        this.effects.cleanup();
        
        // Giảm bộ nhớ canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Thêm vào class BiomeManager
class BiomeManager {
    constructor(game) {
        this.game = game;
        this.currentBiome = 'city';
        this.biomeTransition = 0;
        this.biomes = {
            city: { color: '#00ffff', music: 'city', difficulty: 1 },
            desert: { color: '#ff9900', music: 'desert', difficulty: 1.5 },
            lab: { color: '#ff00ff', music: 'lab', difficulty: 2 },
            forest: { color: '#00ff00', music: 'forest', difficulty: 2.5 },
            hell: { color: '#ff0000', music: 'hell', difficulty: 3 }
        };
        this.visitedBiomes = new Set();
    }

    update(deltaTime) {
        // Chuyển đổi biome theo điểm số
        const score = this.game.state.score;
        if (score < 1000) this.currentBiome = 'city';
        else if (score < 2000) this.currentBiome = 'desert';
        else if (score < 3000) this.currentBiome = 'lab';
        else if (score < 4000) this.currentBiome = 'forest';
        else this.currentBiome = 'hell';

        // Thêm biome vào danh sách đã thăm
        this.visitedBiomes.add(this.currentBiome);

        // Hiệu ứng chuyển đổi biome
        this.biomeTransition += deltaTime * 0.001;
        if (this.biomeTransition > 1) {
            this.biomeTransition = 0;
            this.game.audioManager.playMusic(this.currentBiome);
            this.game.enemyManager.increaseDifficulty();
        }
    }

    render(ctx) {
        const biome = this.biomes[this.currentBiome];
        ctx.fillStyle = biome.color;
        ctx.globalAlpha = 0.1;
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.globalAlpha = 1;
    }
}

// Thêm vào class Player
class Player {
    constructor(game) {
        // Các thuộc tính đã có từ trước...
        this.perfectJumps = 0;
        this.wallClimbs = 0;
        this.comboMultiplier = 1;
        this.lastComboTime = 0;
        this.comboWindow = 2000; // 2 giây để duy trì combo
    }

    handleParkour(deltaTime) {
        // Kiểm tra perfect jump
        if (this.velocity.y > 0 && 
            this.isOnGround() && 
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow) {
            this.perfectJumps++;
            this.game.state.score += 1000 * this.comboMultiplier;
            this.game.audioManager.playSound('powerup');
            this.updateCombo();
        }

        // Xử lý wall slide và climb
        if (this.isAgainstWall()) {
            if (this.states.isWallRunning) {
                this.velocity.y = Math.min(this.velocity.y + 0.5, this.wallSlideVelocity);
            } else if (this.states.isClimbing) {
                this.wallClimbs++;
                this.velocity.y = -this.climbSpeed;
            }
        }

        // Cập nhật combo
        if (performance.now() - this.lastComboTime > this.comboWindow) {
            this.comboMultiplier = 1;
        }
    }

    updateCombo() {
        this.lastComboTime = performance.now();
        this.comboMultiplier = Math.min(5, this.comboMultiplier + 0.5);
    }
}

// Thêm vào class UISystem
class UISystem {
    constructor(game) {
        this.game = game;
        this.fps = 0;
        this.fpsCounter = 0;
        this.lastFpsUpdate = 0;
        this.comboTimer = 0;
    }

    render() {
        const ctx = this.game.ctx;
        const { score, highScore, isRunning } = this.game.state;
        
        // FPS counter
        this.updateFPS();
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.fillText(`FPS: ${this.fps}`, 10, 30);

        // Score và high score
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 50);
        ctx.fillText(`High Score: ${Math.floor(highScore)}`, 10, 70);

        // Combo multiplier
        if (this.game.player.comboMultiplier > 1) {
            this.comboTimer += 1;
            ctx.fillStyle = '#ff4444';
            ctx.font = '24px Arial';
            ctx.fillText(`COMBO x${this.game.player.comboMultiplier.toFixed(1)}`, 
                        this.game.canvas.width - 150, 40);
            
            if (this.comboTimer > 60) {
                this.comboTimer = 0;
            }
        }

        // Achievement notifications
        this.renderAchievementNotifications();
    }

    renderAchievementNotifications() {
        const notifications = document.querySelectorAll('.achievement-notification');
        notifications.forEach(notification => {
            const rect = notification.getBoundingClientRect();
            this.game.ctx.save();
            this.game.ctx.fillStyle = '#00000088';
            this.game.ctx.fillRect(rect.left, rect.top, 
                                rect.width, rect.height);
            this.game.ctx.restore();
        });
    }
}

// Thêm vào class AchievementManager
class AchievementManager {
    constructor(game) {
        this.game = game;
        this.achievements = {
            perfectJump: {
                name: 'Nhảy Hoàn Hảo',
                description: 'Thực hiện 10 perfect jump',
                count: 0,
                unlocked: false,
                reward: 1000
            },
            wallMaster: {
                name: 'Chúa Tường',
                description: 'Leo tường 50 lần',
                count: 0,
                unlocked: false,
                reward: 2000
            },
            biomeExplorer: {
                name: 'Nhà Khám Phá',
                description: 'Khám phá tất cả các biome',
                unlocked: false,
                reward: 5000
            }
        };
    }

    checkAchievements() {
        // Kiểm tra perfect jump achievement
        if (this.game.player.perfectJumps >= 10 && !this.achievements.perfectJump.unlocked) {
            this.unlockAchievement('perfectJump');
        }

        // Kiểm tra wall master achievement
        if (this.game.player.wallClimbs >= 50 && !this.achievements.wallMaster.unlocked) {
            this.unlockAchievement('wallMaster');
        }

        // Kiểm tra biome explorer achievement
        const visitedBiomes = new Set(this.game.biomeManager.visitedBiomes);
        if (visitedBiomes.size === 5 && !this.achievements.biomeExplorer.unlocked) {
            this.unlockAchievement('biomeExplorer');
        }
    }

    unlockAchievement(id) {
        const achievement = this.achievements[id];
        achievement.unlocked = true;
        this.game.state.score += achievement.reward;
        this.game.audioManager.playSound('powerup');
        this.showAchievementNotification(achievement);
    }

    showAchievementNotification(achievement) {
        const notification = document.createElement('div');
        notification.className = 'achievement-notification';
        notification.innerHTML = `
            <h3>Mới Mở Khóa!</h3>
            <p><strong>${achievement.name}</strong></p>
            <p>${achievement.description}</p>
            <p>+${achievement.reward} điểm</p>
        `;
        document.body
       // Thêm vào class AchievementManager
class AchievementManager {
    constructor(game) {
        this.game = game;
        this.achievements = {
            perfectJump: {
                name: 'Nhảy Hoàn Hảo',
                description: 'Thực hiện 10 perfect jump',
                count: 0,
                unlocked: false,
                reward: 1000
            },
            wallMaster: {
                name: 'Chúa Tường',
                description: 'Leo tường 50 lần',
                count: 0,
                unlocked: false,
                reward: 2000
            },
            biomeExplorer: {
                name: 'Nhà Khám Phá',
                description: 'Khám phá tất cả các biome',
                unlocked: false,
                reward: 5000
            }
        };
    }

    checkAchievements() {
        // Kiểm tra perfect jump achievement
        if (this.game.player.perfectJumps >= 10 && !this.achievements.perfectJump.unlocked) {
            this.unlockAchievement('perfectJump');
        }

        // Kiểm tra wall master achievement
        if (this.game.player.wallClimbs >= 50 && !this.achievements.wallMaster.unlocked) {
            this.unlockAchievement('wallMaster');
        }

        // Kiểm tra biome explorer achievement
        const visitedBiomes = new Set(this.game.biomeManager.visitedBiomes);
        if (visitedBiomes.size === 5 && !this.achievements.biomeExplorer.unlocked) {
            this.unlockAchievement('biomeExplorer');
        }
    }

    unlockAchievement(id) {
        const achievement = this.achievements[id];
        achievement.unlocked = true;
        this.game.state.score += achievement.reward;
        this.game.audioManager.playSound('powerup');
        this.showAchievementNotification(achievement);
    }

    showAchievementNotification(achievement) {
        const notification = document.createElement('div');
        notification.className = 'achievement-notification';
        notification.innerHTML = `
            <h3>Mới Mở Khóa!</h3>
            <p><strong>${achievement.name}</strong></p>
            <p>${achievement.description}</p>
            <p>+${achievement.reward} điểm</p>
        `;
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.remove();
        }, 5000);
    }
}

// Thêm vào class GameEngine
class GameEngine {
    constructor() {
        // Các thuộc tính đã có từ trước...
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;
        this.objectPool = new ObjectPool();
        this.memoryUsage = 0;
        this.lastGC = 0;
    }

    update(deltaTime) {
        // Các cập nhật đã có từ trước...
        
        // Quản lý bộ nhớ
        this.memoryUsage += deltaTime;
        if (this.memoryUsage > 5000) { // 5 giây
            this.cleanup();
            this.memoryUsage = 0;
        }
    }

    cleanup() {
        // Dọn dẹp các objects không sử dụng
        this.objectPool.cleanup();
        
        // Xóa các particles cũ
        this.effects.cleanup();
        
        // Giảm bộ nhớ canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

// Thêm vào class BiomeManager
class BiomeManager {
    constructor(game) {
        this.game = game;
        this.currentBiome = 'city';
        this.biomeTransition = 0;
        this.biomes = {
            city: { color: '#00ffff', music: 'city', difficulty: 1 },
            desert: { color: '#ff9900', music: 'desert', difficulty: 1.5 },
            lab: { color: '#ff00ff', music: 'lab', difficulty: 2 },
            forest: { color: '#00ff00', music: 'forest', difficulty: 2.5 },
            hell: { color: '#ff0000', music: 'hell', difficulty: 3 }
        };
        this.visitedBiomes = new Set();
    }

    update(deltaTime) {
        // Chuyển đổi biome theo điểm số
        const score = this.game.state.score;
        if (score < 1000) this.currentBiome = 'city';
        else if (score < 2000) this.currentBiome = 'desert';
        else if (score < 3000) this.currentBiome = 'lab';
        else if (score < 4000) this.currentBiome = 'forest';
        else this.currentBiome = 'hell';

        // Thêm biome vào danh sách đã thăm
        this.visitedBiomes.add(this.currentBiome);

        // Hiệu ứng chuyển đổi biome
        this.biomeTransition += deltaTime * 0.001;
        if (this.biomeTransition > 1) {
            this.biomeTransition = 0;
            this.game.audioManager.playMusic(this.currentBiome);
            this.game.enemyManager.increaseDifficulty();
        }
    }

    render(ctx) {
        const biome = this.biomes[this.currentBiome];
        ctx.fillStyle = biome.color;
        ctx.globalAlpha = 0.1;
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.globalAlpha = 1;
    }
}

// Thêm vào class Player
class Player {
    constructor(game) {
        // Các thuộc tính đã có từ trước...
        this.perfectJumps = 0;
        this.wallClimbs = 0;
        this.comboMultiplier = 1;
        this.lastComboTime = 0;
        this.comboWindow = 2000; // 2 giây để duy trì combo
    }

    handleParkour(deltaTime) {
        // Kiểm tra perfect jump
        if (this.velocity.y > 0 && 
            this.isOnGround() && 
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow) {
            this.perfectJumps++;
            this.game.state.score += 1000 * this.comboMultiplier;
            this.game.audioManager.playSound('powerup');
            this.updateCombo();
        }

        // Xử lý wall slide và climb
        if (this.isAgainstWall()) {
            if (this.states.isWallRunning) {
                this.velocity.y = Math.min(this.velocity.y + 0.5, this.wallSlideVelocity);
            } else if (this.states.isClimbing) {
                this.wallClimbs++;
                this.velocity.y = -this.climbSpeed;
            }
        }

        // Cập nhật combo
        if (performance.now() - this.lastComboTime > this.comboWindow) {
            this.comboMultiplier = 1;
        }
    }

    updateCombo() {
        this.lastComboTime = performance.now();
        this.comboMultiplier = Math.min(5, this.comboMultiplier + 0.5);
    }
}

// Thêm vào class UISystem
class UISystem {
    constructor(game) {
        this.game = game;
        this.fps = 0;
        this.fpsCounter = 0;
        this.lastFpsUpdate = 0;
        this.comboTimer = 0;
    }

    render() {
        const ctx = this.game.ctx;
        const { score, highScore, isRunning } = this.game.state;
        
        // FPS counter
        this.updateFPS();
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.fillText(`FPS: ${this.fps}`, 10, 30);

        // Score và high score
        ctx.fillStyle = '#fff';
        ctx.font = '20px Arial';
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 50);
        ctx.fillText(`High Score: ${Math.floor(highScore)}`, 10, 70);

        // Combo multiplier
        if (this.game.player.comboMultiplier > 1) {
            this.comboTimer += 1;
            ctx.fillStyle = '#ff4444';
            ctx.font = '24px Arial';
            ctx.fillText(`COMBO x${this.game.player.comboMultiplier.toFixed(1)}`, 
                        this.game.canvas.width - 150, 40);
            
            if (this.comboTimer > 60) {
                this.comboTimer = 0;
            }
        }

        // Achievement notifications
        this.renderAchievementNotifications();
    }

    renderAchievementNotifications() {
        const notifications = document.querySelectorAll('.achievement-notification');
        notifications.forEach(notification => {
            const rect = notification.getBoundingClientRect();
            this.game.ctx.save();
            this.game.ctx.fillStyle = '#00000088';
            this.game.ctx.fillRect(rect.left, rect.top, 
                                rect.width, rect.height);
            this.game.ctx.restore();
        });
    }
}
      /* ============================================================
   PHẦN CUỐI GAME — CÁC MODULE NÂNG CẤP HOÀN CHỈNH
   (Dán ngay trước </script>)
============================================================ */

/* =======================
   1. GAME ENGINE UPGRADE
======================= */
class GameEngine {
    constructor() {
        this.targetFPS = 60;
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / this.targetFPS;

        this.objectPool = new ObjectPool();

        this.memoryUsage = 0;
        this.lastGC = performance.now();

        if (!this.canvas) console.warn("⚠ GameEngine: canvas chưa gán!");
        if (!this.ctx) console.warn("⚠ GameEngine: ctx chưa khởi tạo!");
    }

    update(deltaTime) {
        // Update game chính của bạn nằm ở phần trên...

        this.memoryUsage += deltaTime;

        if (performance.now() - this.lastGC > 5000) {
            this.cleanup();
            this.lastGC = performance.now();
        }
    }

    cleanup() {
        if (this.objectPool) this.objectPool.cleanup();
        if (this.effects?.cleanup) this.effects.cleanup();

        // Không clear full canvas ở đây để tránh nháy màn hình
    }
}


/* =======================
   2. BIOME MANAGER UPDATE
======================== */
class BiomeManager {
    constructor(game) {
        this.game = game;

        this.currentBiome = "city";
        this.prevBiome = "city";

        this.transitionProgress = 1;
        this.transitionSpeed = 0.002;

        this.biomes = {
            city:   { color: "#00ffff", music: "city", difficulty: 1 },
            desert: { color: "#ff9900", music: "desert", difficulty: 1.5 },
            lab:    { color: "#ff00ff", music: "lab", difficulty: 2 },
            forest: { color: "#00ff00", music: "forest", difficulty: 2.5 },
            hell:   { color: "#ff0000", music: "hell", difficulty: 3 }
        };

        this.visitedBiomes = new Set();
    }

    update(deltaTime) {
        const score = this.game.state.score;

        let newBiome =
              score < 1000 ? "city"
            : score < 2000 ? "desert"
            : score < 3000 ? "lab"
            : score < 4000 ? "forest"
            : "hell";

        if (newBiome !== this.currentBiome) {
            this.prevBiome = this.currentBiome;
            this.currentBiome = newBiome;
            this.transitionProgress = 0;

            this.game.audioManager.playMusic(newBiome);
            this.game.enemyManager.increaseDifficulty();
        }

        this.visitedBiomes.add(this.currentBiome);

        if (this.transitionProgress < 1) {
            this.transitionProgress += deltaTime * this.transitionSpeed;
        }
    }

    render(ctx) {
        const biome = this.biomes[this.currentBiome];

        ctx.save();
        ctx.globalAlpha = 0.1;
        ctx.fillStyle = biome.color;
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.restore();
    }
}


/* =======================
   3. PLAYER UPGRADE LOGIC
======================== */
class Player {
    constructor(game) {
        this.game = game;

        this.perfectJumps = 0;
        this.wallClimbs = 0;

        this.comboMultiplier = 1;
        this.lastComboTime = 0;
        this.comboWindow = 2000;

        this.lastPerfectJump = 0;
        this.perfectJumpCooldown = 150;
    }

    handleParkour(deltaTime) {
        // PERFECT JUMP
        if (this.velocity.y > 0 &&
            this.isOnGround &&
            performance.now() - this.lastGroundedTime < this.perfectJumpWindow &&
            performance.now() - this.lastPerfectJump > this.perfectJumpCooldown) {
            
            this.perfectJumps++;
            this.game.state.score += 1000 * this.comboMultiplier;

            this.game.audioManager.playSound("powerup");
            this.updateCombo();

            this.lastPerfectJump = performance.now();
        }

        // WALL ACTIONS
        if (this.isAgainstWall && this.states) {
            if (this.states.isWallRunning) {
                this.velocity.y = Math.min(this.velocity.y + 0.5, this.wallSlideVelocity);
            } else if (this.states.isClimbing) {
                this.wallClimbs++;
                this.velocity.y = -this.climbSpeed;
            }
        }

        // RESET COMBO
        if (performance.now() - this.lastComboTime > this.comboWindow) {
            this.comboMultiplier = 1;
        }
    }

    updateCombo() {
        this.lastComboTime = performance.now();
        this.comboMultiplier = Math.min(5, this.comboMultiplier + 0.5);
    }
}


/* =======================
   4. UI SYSTEM UPGRADE
======================== */
class UISystem {
    constructor(game) {
        this.game = game;

        this.fps = 0;
        this.lastFPS = performance.now();

        this.comboTimer = 0;
    }

    updateFPS() {
        const now = performance.now();
        const delta = now - this.lastFPS;

        if (delta > 500) {
            this.fps = Math.round(1000 / this.game.deltaTime);
            this.lastFPS = now;
        }
    }

    render() {
        const ctx = this.game.ctx;
        const { score, highScore } = this.game.state;

        this.updateFPS();

        ctx.fillStyle = "#fff";
        ctx.font = "16px Arial";
        ctx.fillText(`FPS: ${this.fps}`, 10, 30);

        ctx.font = "20px Arial";
        ctx.fillText(`Score: ${Math.floor(score)}`, 10, 50);
        ctx.fillText(`High Score: ${Math.floor(highScore)}`, 10, 70);

        if (this.game.player.comboMultiplier > 1) {
            ctx.fillStyle = "#ff4444";
            ctx.font = "24px Arial";
            ctx.fillText(
                `COMBO x${this.game.player.comboMultiplier.toFixed(1)}`,
                this.game.canvas.width - 180,
                40
            );
        }

        this.renderAchievementNotifications();
    }

    renderAchievementNotifications() {
        const notifications = document.querySelectorAll(".achievement-notification");
        const ctx = this.game.ctx;

        notifications.forEach(noti => {
            const r = noti.getBoundingClientRect();

            ctx.save();
            ctx.fillStyle = "#0008";
            ctx.fillRect(r.left, r.top, r.width, r.height);
            ctx.restore();
        });
    }
}

/* ====== KẾT THÚC PHẦN CUỐI GAME ====== */
