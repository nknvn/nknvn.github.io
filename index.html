<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>knake Game - N·∫Øc SƒÉn L·ªìL</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        #gameContainer {
            width: 90vmin;
            height: 90vmin;
            max-width: 600px;
            max-height: 600px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 4px solid #00d4ff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5), inset 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* ===== HUD - TH√îNG TIN TR√í CH∆†I ===== */
        #hud {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 12px 20px;
            background: rgba(0, 20, 40, 0.9);
            border-bottom: 2px solid #00d4ff;
            gap: 15px;
            flex-wrap: wrap;
        }

        .hud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            min-width: 80px;
        }

        .hud-label {
            font-size: 0.85rem;
            color: #00d4ff;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .hud-value {
            font-size: 1.4rem;
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        /* ===== CANVAS GAME ===== */
        #gameCanvas {
            flex: 1;
            display: block;
            background: #0f0f1e;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        /* ===== CONTROL BUTTONS ===== */
        #mobileControls {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            padding: 12px;
            background: rgba(0, 20, 40, 0.9);
            border-top: 2px solid #00d4ff;
        }

        .control-btn {
            padding: 12px;
            background: linear-gradient(135deg, #00d4ff 0%, #0099ff 100%);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.5);
        }

        .control-btn:hover {
            background: linear-gradient(135deg, #00ffff 0%, #00ccff 100%);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }

        #btnUp {
            grid-column: 2;
            grid-row: 1;
        }

        #btnLeft {
            grid-column: 1;
            grid-row: 2;
        }

        #btnPause {
            grid-column: 2;
            grid-row: 2;
        }

        #btnRight {
            grid-column: 3;
            grid-row: 2;
        }

        #btnDown {
            grid-column: 2;
            grid-row: 3;
        }

        /* ===== OVERLAY ===== */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            gap: 30px;
            backdrop-filter: blur(5px);
        }

        #overlay.show {
            display: flex;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .overlay-content {
            text-align: center;
            color: white;
            animation: scaleIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .overlay-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            color: #00ff88;
        }

        .overlay-subtitle {
            font-size: 1.2rem;
            color: #00d4ff;
            margin-bottom: 10px;
        }

        .overlay-stats {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
            font-size: 1.3rem;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            gap: 30px;
            padding: 10px 20px;
            background: rgba(0, 212, 255, 0.1);
            border-left: 3px solid #00ff88;
            border-radius: 5px;
        }

        .stat-label {
            color: #00d4ff;
            font-weight: bold;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.6);
        }

        .button-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .main-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #00ff88 0%, #00dd66 100%);
            border: none;
            border-radius: 10px;
            color: #000;
            font-weight: bold;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .main-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(0, 255, 136, 0.6);
        }

        .main-btn:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.4);
        }

        .secondary-btn {
            padding: 12px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid #00d4ff;
            border-radius: 8px;
            color: #00d4ff;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .secondary-btn:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
        }

        .secondary-btn:active {
            transform: scale(0.98);
        }

        /* ===== PAUSE SCREEN ===== */
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999;
            gap: 30px;
        }

        #pauseOverlay.show {
            display: flex;
            animation: fadeIn 0.2s ease-in;
        }

        .pause-content {
            text-align: center;
            color: white;
            animation: scaleIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .pause-title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(0, 255, 136, 0.8);
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 600px) {
            #gameContainer {
                width: 95vw;
                height: 95vw;
                max-width: none;
                max-height: none;
            }

            #mobileControls {
                display: grid;
            }

            #hud {
                padding: 10px 12px;
                gap: 8px;
            }

            .hud-item {
                min-width: 70px;
            }

            .hud-label {
                font-size: 0.7rem;
            }

            .hud-value {
                font-size: 1.2rem;
            }

            .overlay-title {
                font-size: 2rem;
            }

            .overlay-subtitle {
                font-size: 1rem;
            }

            .stat-line {
                font-size: 1rem;
            }

            .main-btn {
                padding: 12px 30px;
                font-size: 1rem;
            }
        }

        @media (max-width: 400px) {
            #gameContainer {
                border-width: 2px;
            }

            .hud-label {
                font-size: 0.65rem;
            }

            .hud-value {
                font-size: 1rem;
            }

            .control-btn {
                padding: 10px;
                font-size: 1rem;
            }
        }

        /* ===== ANIMATIONS ===== */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        @keyframes glow {
            0%, 100% {
                text-shadow: 0 0 5px rgba(0, 255, 136, 0.5);
            }
            50% {
                text-shadow: 0 0 20px rgba(0, 255, 136, 1);
            }
        }

        .score-gain {
            animation: scoreGain 0.6s ease-out;
        }

        @keyframes scoreGain {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(1.2);
            }
        }
    </style>
</head>
<body>
    <!-- MAIN GAME CONTAINER -->
    <div id="gameContainer">
        <!-- HUD - Hi·ªÉn th·ªã ƒëi·ªÉm, level, high score -->
        <div id="hud">
            <div class="hud-item">
                <span class="hud-label">Score</span>
                <span class="hud-value" id="scoreDisplay">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">Level</span>
                <span class="hud-value" id="levelDisplay">1</span>
            </div>
            <div class="hud-item">
                <span class="hud-label">High Score</span>
                <span class="hud-value" id="highScoreDisplay">0</span>
            </div>
        </div>

        <!-- CANVAS GAME -->
        <canvas id="gameCanvas"></canvas>

        <!-- MOBILE CONTROLS -->
        <div id="mobileControls">
            <button class="control-btn" id="btnUp">‚ñ≤</button>
            <button class="control-btn" id="btnLeft">‚óÑ</button>
            <button class="control-btn" id="btnPause">‚è∏</button>
            <button class="control-btn" id="btnRight">‚ñ∫</button>
            <button class="control-btn" id="btnDown">‚ñº</button>
        </div>

        <!-- OVERLAY - START, GAME OVER -->
        <div id="overlay">
            <div class="overlay-content">
                <div class="overlay-title" id="overlayTitle">SNAKE GAME</div>
                <div class="overlay-subtitle" id="overlaySubtitle">Nh·∫•n ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
                <div class="overlay-stats" id="overlayStats"></div>
                <div class="button-group" id="overlayButtons"></div>
            </div>
        </div>

        <!-- PAUSE OVERLAY -->
        <div id="pauseOverlay">
            <div class="pause-content">
                <div class="pause-title">GAME PAUSED</div>
                <div class="button-group">
                    <button class="main-btn" id="btnResume">Continue</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===== GAME CONFIGURATION =====
        const GRID_SIZE = 20; // K√≠ch th∆∞·ªõc c·ªßa m·ªôt √¥
        const INITIAL_SPEED = 100; // T·ªëc ƒë·ªô ban ƒë·∫ßu (ms)
        const SPEED_INCREASE = 5; // TƒÉng t·ªëc ƒë·ªô m·ªói level
        const LEVEL_UP_SCORE = 50; // ƒêi·ªÉm ƒë·ªÉ tƒÉng level
        const MAX_OBSTACLES = 5; // S·ªë ch∆∞·ªõng ng·∫°i v·∫≠t t·ªëi ƒëa

        // ===== GAME STATE =====
        let gameState = 'start'; // 'start', 'playing', 'paused', 'gameOver'
        let score = 0;
        let highScore = localStorage.getItem('snakeGameHighScore') || 0;
        let level = 1;
        let gameSpeed = INITIAL_SPEED;
        let lastFrameTime = 0;
        let deltaTime = 0;

        // ===== CANVAS & CONTEXT =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ===== SNAKE & GAME OBJECTS =====
        let snake = [];
        let food = {};
        let obstacles = [];
        let nextDirection = { x: 1, y: 0 }; // H∆∞·ªõng ti·∫øp theo (ph·∫£i)
        let currentDirection = { x: 1, y: 0 }; // H∆∞·ªõng hi·ªán t·∫°i

        // ===== UI ELEMENTS =====
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const overlay = document.getElementById('overlay');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const mobileControls = document.getElementById('mobileControls');

        // ===== TOUCH INPUT =====
        let touchStartX = 0;
        let touchStartY = 0;
        let lastSwipeTime = 0;

        // ===== INITIALIZATION =====
        function init() {
            // Resize canvas
            resizeCanvas();

            // Initialize snake
            snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];

            // Reset game state
            score = 0;
            level = 1;
            gameSpeed = INITIAL_SPEED;
            nextDirection = { x: 1, y: 0 };
            currentDirection = { x: 1, y: 0 };
            obstacles = [];

            // Generate initial food and obstacles
            generateFood();
            generateObstacles();

            // Update display
            updateDisplay();
            highScoreDisplay.textContent = highScore;

            // Show start screen
            showStartScreen();
        }

        // ===== CANVAS RESIZE =====
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight - mobileControls.clientHeight - document.getElementById('hud').clientHeight;
            canvas.width = Math.floor(canvas.width / GRID_SIZE) * GRID_SIZE;
            canvas.height = Math.floor(canvas.height / GRID_SIZE) * GRID_SIZE;
        }

        // ===== SHOW START SCREEN =====
        function showStartScreen() {
            gameState = 'start';
            overlay.classList.add('show');
            const overlayTitle = document.getElementById('overlayTitle');
            const overlaySubtitle = document.getElementById('overlaySubtitle');
            const overlayButtons = document.getElementById('overlayButtons');
            const overlayStats = document.getElementById('overlayStats');

            overlayTitle.textContent = 'SNAKE GAME';
            overlaySubtitle.textContent = 'R·∫Øn SƒÉn M·ªìi';
            
            overlayStats.innerHTML = `
                <div class="stat-line">
                    <span class="stat-label">High Score:</span>
                    <span class="stat-value">${highScore}</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">H∆∞·ªõng d·∫´n:</span>
                    <span class="stat-value">M≈©i t√™n ho·∫∑c WASD</span>
                </div>
            `;

            overlayButtons.innerHTML = `
                <button class="main-btn" id="btnStartGame">START GAME</button>
            `;

            document.getElementById('btnStartGame').addEventListener('click', startGame);
        }

        // ===== SHOW GAME OVER SCREEN =====
        function showGameOverScreen() {
            gameState = 'gameOver';
            overlay.classList.add('show');
            const overlayTitle = document.getElementById('overlayTitle');
            const overlaySubtitle = document.getElementById('overlaySubtitle');
            const overlayButtons = document.getElementById('overlayButtons');
            const overlayStats = document.getElementById('overlayStats');

            overlayTitle.textContent = 'GAME OVER';
            overlaySubtitle.textContent = 'üò¢';
            
            overlayStats.innerHTML = `
                <div class="stat-line">
                    <span class="stat-label">Score:</span>
                    <span class="stat-value">${score}</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Level:</span>
                    <span class="stat-value">${level}</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">High Score:</span>
                    <span class="stat-value">${highScore}</span>
                </div>
            `;

            overlayButtons.innerHTML = `
                <button class="main-btn" id="btnPlayAgain">PLAY AGAIN</button>
                <button class="secondary-btn" id="btnMenu">MENU</button>
            `;

            document.getElementById('btnPlayAgain').addEventListener('click', () => {
                overlay.classList.remove('show');
                init();
                startGame();
            });

            document.getElementById('btnMenu').addEventListener('click', () => {
                overlay.classList.remove('show');
                init();
            });

            // Play game over sound
            playGameOverSound();
        }

        // ===== START GAME =====
        function startGame() {
            overlay.classList.remove('show');
            pauseOverlay.classList.remove('show');
            gameState = 'playing';
            lastFrameTime = Date.now();
            gameLoop(lastFrameTime);
        }

        // ===== PAUSE & RESUME =====
        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseOverlay.classList.add('show');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                pauseOverlay.classList.remove('show');
                lastFrameTime = Date.now();
                gameLoop(lastFrameTime);
            }
        }

        // ===== UPDATE DISPLAY =====
        function updateDisplay() {
            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            highScoreDisplay.textContent = highScore;
        }

        // ===== GENERATE FOOD =====
        function generateFood() {
            let newFood;
            let validPosition = false;

            while (!validPosition) {
                newFood = {
                    x: Math.floor(Math.random() * (canvas.width / GRID_SIZE)),
                    y: Math.floor(Math.random() * (canvas.height / GRID_SIZE))
                };

                // Ki·ªÉm tra xem food kh√¥ng tr√πng v·ªõi snake ho·∫∑c obstacles
                validPosition = !isPositionOccupied(newFood.x, newFood.y);
            }

            food = newFood;
        }

        // ===== GENERATE OBSTACLES =====
        function generateObstacles() {
            const maxObstacles = Math.min(MAX_OBSTACLES, Math.floor(level / 2) + 1);
            obstacles = [];

            while (obstacles.length < maxObstacles) {
                const obstacle = {
                    x: Math.floor(Math.random() * (canvas.width / GRID_SIZE)),
                    y: Math.floor(Math.random() * (canvas.height / GRID_SIZE))
                };

                // Ki·ªÉm tra xem obstacle kh√¥ng tr√πng v·ªõi snake ho·∫∑c food
                if (!isPositionOccupied(obstacle.x, obstacle.y) && 
                    !(obstacle.x === food.x && obstacle.y === food.y)) {
                    obstacles.push(obstacle);
                }
            }
        }

        // ===== CHECK POSITION OCCUPIED =====
        function isPositionOccupied(x, y) {
            // Ki·ªÉm tra snake
            for (let segment of snake) {
                if (segment.x === x && segment.y === y) return true;
            }

            // Ki·ªÉm tra obstacles
            for (let obstacle of obstacles) {
                if (obstacle.x === x && obstacle.y === y) return true;
            }

            return false;
        }

        // ===== MAIN GAME LOOP =====
        function gameLoop(currentTime) {
            if (gameState !== 'playing') {
                if (gameState === 'playing') {
                    requestAnimationFrame(gameLoop);
                }
                return;
            }

            deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            if (deltaTime >= gameSpeed) {
                // Update
                update();

                // Draw
                draw();

                lastFrameTime = currentTime;
            }

            requestAnimationFrame(gameLoop);
        }

        // ===== UPDATE GAME STATE =====
        function update() {
            // Update direction
            currentDirection = { ...nextDirection };

            // Calculate new head position
            const head = snake[0];
            const newHead = {
                x: head.x + currentDirection.x,
                y: head.y + currentDirection.y
            };

            // Check collisions
            if (checkCollisions(newHead)) {
                showGameOverScreen();
                return;
            }

            // Add new head
            snake.unshift(newHead);

            // Check if eaten food
            if (newHead.x === food.x && newHead.y === food.y) {
                score += 10;
                playEatSound();

                // Check level up
                const newLevel = Math.floor(score / LEVEL_UP_SCORE) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    gameSpeed = Math.max(INITIAL_SPEED - (level - 1) * SPEED_INCREASE, 50);
                    generateObstacles();
                }

                generateFood();
                updateDisplay();
            } else {
                // Remove tail if not eaten
                snake.pop();
            }
        }

        // ===== CHECK COLLISIONS =====
        function checkCollisions(head) {
            // Check wall collision
            if (head.x < 0 || head.x >= canvas.width / GRID_SIZE ||
                head.y < 0 || head.y >= canvas.height / GRID_SIZE) {
                return true;
            }

            // Check self collision
            for (let segment of snake) {
                if (head.x === segment.x && head.y === segment.y) {
                    return true;
                }
            }

            // Check obstacles collision
            for (let obstacle of obstacles) {
                if (head.x === obstacle.x && head.y === obstacle.y) {
                    return true;
                }
            }

            return false;
        }

        // ===== DRAW GAME =====
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0f0f1e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid (optional)
            drawGrid();

            // Draw snake
            drawSnake();

            // Draw food
            drawFood();

            // Draw obstacles
            drawObstacles();
        }

        // ===== DRAW GRID =====
        function drawGrid() {
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.05)';
            ctx.lineWidth = 0.5;

            // Vertical lines
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // ===== DRAW SNAKE =====
        function drawSnake() {
            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                const x = segment.x * GRID_SIZE;
                const y = segment.y * GRID_SIZE;

                if (i === 0) {
                    // Draw head
                    ctx.fillStyle = '#00ff88';
                    ctx.shadowColor = 'rgba(0, 255, 136, 0.8)';
                    ctx.shadowBlur = 15;
                    ctx.fillRect(x + 1, y + 1, GRID_SIZE - 2, GRID_SIZE - 2);
                    ctx.shadowBlur = 0;

                    // Draw eyes
                    ctx.fillStyle = '#000';
                    const eyeSize = GRID_SIZE / 4;
                    const eyeDistance = GRID_SIZE / 3;

                    if (currentDirection.x === 1) { // Moving right
                        ctx.fillRect(x + eyeDistance, y + eyeDistance / 2, eyeSize, eyeSize);
                        ctx.fillRect(x + eyeDistance, y + eyeDistance * 1.5, eyeSize, eyeSize);
                    } else if (currentDirection.x === -1) { // Moving left
                        ctx.fillRect(x + GRID_SIZE - eyeDistance - eyeSize, y + eyeDistance / 2, eyeSize, eyeSize);
                        ctx.fillRect(x + GRID_SIZE - eyeDistance - eyeSize, y + eyeDistance * 1.5, eyeSize, eyeSize);
                    } else if (currentDirection.y === -1) { // Moving up
                        ctx.fillRect(x + eyeDistance / 2, y + GRID_SIZE - eyeDistance - eyeSize, eyeSize, eyeSize);
                        ctx.fillRect(x + eyeDistance * 1.5, y + GRID_SIZE - eyeDistance - eyeSize, eyeSize, eyeSize);
                    } else { // Moving down
                        ctx.fillRect(x + eyeDistance / 2, y + eyeDistance, eyeSize, eyeSize);
                        ctx.fillRect(x + eyeDistance * 1.5, y + eyeDistance, eyeSize, eyeSize);
                    }
                } else {
                    // Draw body
                    const opacity = 1 - (i / snake.length) * 0.5;
                    ctx.fillStyle = `rgba(0, 255, 136, ${opacity})`;
                    ctx.shadowColor = `rgba(0, 255, 136, ${opacity * 0.5})`;
                    ctx.shadowBlur = 8;
                    ctx.fillRect(x + 2, y + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                    ctx.shadowBlur = 0;
                }
            }
        }

        // ===== DRAW FOOD =====
        function drawFood() {
            const x = food.x * GRID_SIZE;
            const y = food.y * GRID_SIZE;

            ctx.fillStyle = '#ff4444';
            ctx.shadowColor = 'rgba(255, 68, 68, 0.8)';
            ctx.shadowBlur = 12;

            // Draw circle
            ctx.beginPath();
            ctx.arc(x + GRID_SIZE / 2, y + GRID_SIZE / 2, GRID_SIZE / 2 - 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;
        }

        // ===== DRAW OBSTACLES =====
        function drawObstacles() {
            ctx.fillStyle = '#666666';
            ctx.shadowColor = 'rgba(102, 102, 102, 0.5)';
            ctx.shadowBlur = 5;

            for (let obstacle of obstacles) {
                const x = obstacle.x * GRID_SIZE;
                const y = obstacle.y * GRID_SIZE;

                // Draw square with pattern
                ctx.fillRect(x + 2, y + 2, GRID_SIZE - 4, GRID_SIZE - 4);

                // Draw cross pattern
                ctx.strokeStyle = '#444444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 2, y + 2);
                ctx.lineTo(x + GRID_SIZE - 2, y + GRID_SIZE - 2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x + GRID_SIZE - 2, y + 2);
                ctx.lineTo(x + 2, y + GRID_SIZE - 2);
                ctx.stroke();
            }

            ctx.shadowBlur = 0;
        }

        // ===== INPUT HANDLING =====
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing' && gameState !== 'paused') return;

            switch (e.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    if (currentDirection.y === 0) nextDirection = { x: 0, y: -1 };
                    e.preventDefault();
                    break;
                case 'arrowdown':
                case 's':
                    if (currentDirection.y === 0) nextDirection = { x: 0, y: 1 };
                    e.preventDefault();
                    break;
                case 'arrowleft':
                case 'a':
                    if (currentDirection.x === 0) nextDirection = { x: -1, y: 0 };
                    e.preventDefault();
                    break;
                case 'arrowright':
                case 'd':
                    if (currentDirection.x === 0) nextDirection = { x: 1, y: 0 };
                    e.preventDefault();
                    break;
                case ' ':
                    togglePause();
                    e.preventDefault();
                    break;
            }
        });

        // ===== TOUCH INPUT =====
        canvas.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            lastSwipeTime = Date.now();
        }, false);

        canvas.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const timeDiff = Date.now() - lastSwipeTime;

            // Ki·ªÉm tra n·∫øu l√† swipe (di chuy·ªÉn √≠t nh·∫•t 30px v√† nhanh h∆°n 300ms)
            if (distance > 30 && timeDiff < 300) {
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Horizontal swipe
                    if (deltaX > 0 && currentDirection.x === 0) {
                        nextDirection = { x: 1, y: 0 };
                    } else if (deltaX < 0 && currentDirection.x === 0) {
                        nextDirection = { x: -1, y: 0 };
                    }
                } else {
                    // Vertical swipe
                    if (deltaY > 0 && currentDirection.y === 0) {
                        nextDirection = { x: 0, y: 1 };
                    } else if (deltaY < 0 && currentDirection.y === 0) {
                        nextDirection = { x: 0, y: -1 };
                    }
                }
            }
        }, false);

        // ===== MOBILE BUTTONS =====
        document.getElementById('btnUp').addEventListener('click', () => {
            if (gameState === 'playing' && currentDirection.y === 0) {
                nextDirection = { x: 0, y: -1 };
            }
        });

        document.getElementById('btnDown').addEventListener('click', () => {
            if (gameState === 'playing' && currentDirection.y === 0) {
                nextDirection = { x: 0, y: 1 };
            }
        });

        document.getElementById('btnLeft').addEventListener('click', () => {
            if (gameState === 'playing' && currentDirection.x === 0) {
                nextDirection = { x: -1, y: 0 };
            }
        });

        document.getElementById('btnRight').addEventListener('click', () => {
            if (gameState === 'playing' && currentDirection.x === 0) {
                nextDirection = { x: 1, y: 0 };
            }
        });

        document.getElementById('btnPause').addEventListener('click', () => {
            if (gameState === 'playing' || gameState === 'paused') {
                togglePause();
            }
        });

        document.getElementById('btnResume').addEventListener('click', () => {
            togglePause();
        });

        // ===== SOUND EFFECTS =====
        function playEatSound() {
            // T·∫°o √¢m thanh khi ƒÉn b·∫±ng Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = 800;
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                // Fallback n·∫øu Web Audio API kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£
            }
        }

        function playGameOverSound() {
            // T·∫°o √¢m thanh khi thua b·∫±ng Web Audio API
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.linearRampToValueAtTime(200, audioContext.currentTime + 0.3);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                // Fallback n·∫øu Web Audio API kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£
            }
        }

        // ===== WINDOW RESIZE =====
        window.addEventListener('resize', () => {
            resizeCanvas();
        });

        // ===== SAVE HIGH SCORE =====
        window.addEventListener('beforeunload', () => {
            localStorage.setItem('snakeGameHighScore', highScore);
        });

        // ===== START GAME ON LOAD =====
        window.addEventListener('load', () => {
            init();
        });

        // Prevent default touch behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
