// ===== PHẦN 1 =====
<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PARKOUR ULTIMATE SOUL — GOD MODE 7.1 FULL</title>
<style>
/* =====================
   RESET & GLOBAL
===================== */
html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    background: linear-gradient(135deg, #000 0%, #111 50%, #000 100%);
    color: #0ff;
    touch-action: none;
    animation: backgroundPulse 10s infinite alternate;
}
@keyframes backgroundPulse {
    0% { background: linear-gradient(135deg, #000 0%, #111 50%, #000 100%); }
    100% { background: linear-gradient(135deg, #001 0%, #222 50%, #001 100%); }
}
canvas { 
    display: block; 
    background: radial-gradient(circle, #000 0%, #111 100%); 
    border: 2px solid #0ff;
    box-shadow: 0 0 20px #0ff;
}

/* =====================
   UI LAYER
===================== */
#uiLayer {
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none; z-index: 100;
    font-size: 14px; /* Base font size for scaling */
}

/* Buttons */
button {
    font-family: 'Press Start 2P', monospace;
    cursor: pointer;
    transition: all 0.3s ease;
}
button.uiButton {
    margin: 15px; 
    padding: 20px 40px;
    background: linear-gradient(45deg, #0ff, #00aaff);
    color: #000;
    border: 2px solid #0ff;
    border-radius: 15px;
    font-size: 1.2em; 
    text-shadow: 0 0 5px #0ff;
    box-shadow: 0 0 10px #0ff;
    position: relative;
    overflow: hidden;
}
button.uiButton::before {
    content: '';
    position: absolute;
    top: 0; left: -100%;
    width: 100%; height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
    transition: left 0.5s;
}
button.uiButton:hover::before {
    left: 100%;
}
button.uiButton:hover { 
    background: linear-gradient(45deg, #00aaff, #0ff);
    color: #fff; 
    transform: scale(1.05);
    box-shadow: 0 0 20px #0ff;
}
button.uiButton:active {
    transform: scale(0.95);
}

/* =====================
   SCREENS
===================== */
#menuScreen, #deathScreen, #shopScreen, #optionsScreen, #leaderboardScreen, #creditsScreen, #bossIntro {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex; justify-content: center; align-items: center;
    flex-direction: column;
    background: rgba(0,0,0,0.9);
    backdrop-filter: blur(5px);
    color: #0ff;
    font-size: 1.5em;
    z-index: 100;
    transition: all 0.5s ease;
    opacity: 1;
    text-align: center;
}
#menuScreen.hide, #deathScreen.hide, #shopScreen.hide, #optionsScreen.hide, #leaderboardScreen.hide, #creditsScreen.hide, #bossIntro.hide {
    opacity: 0; 
    pointer-events: none;
    transform: scale(0.9);
}
#menuScreen div:first-child {
    font-size: 2.5em;
    margin-bottom: 20px;
    text-shadow: 0 0 10px #0ff;
    animation: titleGlow 2s infinite alternate;
}
@keyframes titleGlow {
    0% { text-shadow: 0 0 10px #0ff; }
    100% { text-shadow: 0 0 20px #0ff, 0 0 30px #0ff; }
}
#shopScreen, #optionsScreen, #leaderboardScreen, #creditsScreen {
    justify-content: flex-start;
    padding-top: 100px;
}
#shopScreen button, #optionsScreen button, #leaderboardScreen button, #creditsScreen button {
    font-size: 1em;
}
#leaderboardList {
    margin: 20px;
    font-size: 0.8em;
    color: #fff;
    background: rgba(0,255,255,0.1);
    padding: 10px;
    border-radius: 10px;
    border: 1px solid #0ff;
}
#bossIntro {
    background: rgba(255,0,0,0.8);
    animation: bossIntroShake 0.5s infinite;
}
@keyframes bossIntroShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}
#bossName {
    font-size: 3em;
    color: #ff0;
    text-shadow: 0 0 15px #ff0;
}

/* =====================
   MOBILE CONTROLS
===================== */
#mobileControls {
    position: fixed; bottom: 20px; width: 100%;
    display: flex; justify-content: space-around;
    z-index: 99;
    pointer-events: auto; /* Allow interaction */
}
.mobileBtn {
    width: 90px; height: 90px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(0,255,255,0.5), rgba(0,255,255,0.2));
    border: 3px solid #0ff;
    display: flex; align-items: center; justify-content: center;
    font-size: 2em;
    color: #000;
    text-shadow: 0 0 5px #0ff;
    touch-action: none;
    transition: all 0.2s ease;
    box-shadow: 0 0 10px #0ff;
}
.mobileBtn:active { 
    background: radial-gradient(circle, rgba(0,255,255,0.8), rgba(0,255,255,0.4));
    transform: scale(0.9);
    box-shadow: 0 0 20px #0ff;
}

/* =====================
   BIOME OVERLAY
===================== */
#biomeOverlay {
    position: absolute; top: 0; left: 0;
    width: 100%; height: 100%;
    mix-blend-mode: overlay;
    pointer-events: none;
    transition: background 1s ease;
}

/* Particle system (for UI if needed, but mainly for game) */
.particle {
    position: absolute;
    pointer-events: none;
    width: 5px; height: 5px;
    border-radius: 50%;
    background: #fff;
    animation: particleFade 1s forwards;
}
@keyframes particleFade {
    0% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(0); }
}

/* Font import */
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
body { font-family: 'Press Start 2P', monospace; }
audio { display: none; }

/* Responsive adjustments */
@media (max-width: 768px) {
    #menuScreen div:first-child {
        font-size: 1.8em;
    }
    button.uiButton {
        padding: 15px 30px;
        font-size: 1em;
    }
    .mobileBtn {
        width: 70px; height: 70px;
        font-size: 1.5em;
    }
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<div id="uiLayer">
    <!-- MENU -->
    <div id="menuScreen">
        <div>PARKOUR ULTIMATE SOUL<br>GOD MODE 7.1 FULL</div>
        <button class="uiButton" onclick="startGame()">START</button>
        <button class="uiButton" onclick="showOptions()">OPTIONS</button>
        <button class="uiButton" onclick="showShop()">SHOP</button>
        <button class="uiButton" onclick="showLeaderboard()">LEADERBOARD</button>
        <button class="uiButton" onclick="showCredits()">CREDITS</button>
    </div>

    <!-- DEATH -->
    <div id="deathScreen" class="hide">
        <div>YOU DIED</div>
        <button class="uiButton" onclick="restartGame()">RETRY</button>
        <button class="uiButton" onclick="showMenu()">MENU</button>
    </div>
    <!-- SHOP -->
    <div id="shopScreen" class="hide">
        <div>SHOP</div>
        <button class="uiButton" onclick="buyUpgrade('speed')">SPEED</button>
        <button class="uiButton" onclick="buyUpgrade('jump')">JUMP</button>
        <button class="uiButton" onclick="buyUpgrade('dash')">DASH</button>
        <button class="uiButton" onclick="buyUpgrade('shield')">SHIELD</button>
        <button class="uiButton" onclick="buyUpgrade('revive')">REVIVE</button>
        <button class="uiButton" onclick="buyUpgrade('skin')">SKIN</button>
        <button class="uiButton" onclick="closeShop()">BACK</button>
    </div>

    <!-- OPTIONS -->
    <div id="optionsScreen" class="hide">
        <div>OPTIONS</div>
        <button class="uiButton" onclick="toggleAudio()">TOGGLE MUSIC</button>
        <button class="uiButton" onclick="closeOptions()">BACK</button>
    </div>

    <!-- LEADERBOARD -->
    <div id="leaderboardScreen" class="hide">
        <div>LEADERBOARD</div>
        <div id="leaderboardList">No records yet</div>
        <button class="uiButton" onclick="closeLeaderboard()">BACK</button>
    </div>

    <!-- CREDITS -->
    <div id="creditsScreen" class="hide">
        <div>CREDITS</div>
        <div>Created by Ngọc Khôi Nguyễn</div>
        <button class="uiButton" onclick="closeCredits()">BACK</button>
    </div>

    <!-- BOSS INTRO -->
    <div id="bossIntro" class="hide">
        <div id="bossName">BOSS</div>
    </div>

    <!-- MOBILE CONTROLS -->
    <div id="mobileControls">
        <div class="mobileBtn" id="leftBtn">◀</div>
        <div class="mobileBtn" id="jumpBtn">▲</div>
        <div class="mobileBtn" id="dashBtn">▶</div>
    </div>

    <!-- BIOME OVERLAY -->
    <div id="biomeOverlay"></div>
</div>

<!-- AUDIO -->
<audio id="bgMusic" loop src="bgm.mp3"></audio>
<audio id="jumpSnd" src="jump.wav"></audio>
<audio id="dashSnd" src="dash.wav"></audio>
<audio id="hitSnd" src="hit.wav"></audio>
<audio id="bossSnd" src="boss.wav"></audio>
<audio id="coinSnd" src="coin.wav"></audio>

<script>
// ===== PHẦN 2 =====
// =====================
// GLOBAL VARIABLES
// =====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

let gameState = 'menu';
let keys = {};
let player = {};
let platforms = [];
let enemies = [];
let particles = [];
let biomes = [];
let currentBiome = 0;
let camera = {x:0, y:0};
let upgrades = {speed:0, jump:0, dash:0, shield:false, revive:0, skin:0};
let coins = 0;
let audio = {
    bg: document.getElementById('bgMusic'),
    jump: document.getElementById('jumpSnd'),
    dash: document.getElementById('dashSnd'),
    hit: document.getElementById('hitSnd'),
    boss: document.getElementById('bossSnd'),
    coin: document.getElementById('coinSnd')
};
let lastTime = 0;
let bosses = [];
let boss = null;

// =====================
// EVENT LISTENERS
// =====================
window.addEventListener('keydown', e=>keys[e.code]=true);
window.addEventListener('keyup', e=>keys[e.code]=false);
window.addEventListener('resize', ()=>{
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
});

// =====================
// MOBILE BUTTONS
// =====================
document.getElementById('leftBtn').addEventListener('touchstart',()=>keys['ArrowLeft']=true);
document.getElementById('leftBtn').addEventListener('touchend',()=>keys['ArrowLeft']=false);
document.getElementById('jumpBtn').addEventListener('touchstart',()=>keys['Space']=true);
document.getElementById('jumpBtn').addEventListener('touchend',()=>keys['Space']=false);
document.getElementById('dashBtn').addEventListener('touchstart',()=>keys['KeyX']=true);
document.getElementById('dashBtn').addEventListener('touchend',()=>keys['KeyX']=false);

// =====================
// KEY SHORTCUTS
// =====================
window.addEventListener('keydown', e=>{
    if(e.code==='KeyR') restartGame();
    if(e.code==='KeyM') showMenu();
    if(e.code==='KeyS') showShop();
    if(e.code==='KeyO') showOptions();
    if(e.code==='KeyL') showLeaderboard();
});
// ===== PHẦN 3 =====
// =====================
// PLAYER INIT
// =====================
function initPlayer(){
    player = {
        x: width/2, y: height-150,
        w: 50, h: 80,
        vx:0, vy:0,
        speed:5+upgrades.speed,
        jump:15+upgrades.jump,
        dash:20+upgrades.dash,
        onGround:false,
        shield: upgrades.shield,
        dashCooldown:0,
        doubleJump:true,
        health:100,
        maxHealth:100
    };
}

// =====================
// PLATFORM GENERATION
// =====================
function generatePlatforms(){
    platforms = [];
    let y = height - 50;
    for(let i=0;i<200;i++){
        let w = 100 + Math.random()*200;
        platforms.push({x:i*250 + Math.random()*100, y:y, w:w, h:20, type:'normal'});
        y -= Math.random()*100;
        if(y<100) y = height - 50;
    }
}

// =====================
// PLAYER INPUT
// =====================
function handleInput(){
    // Left / Right movement
    if(keys['ArrowLeft']) player.vx = -player.speed;
    else if(keys['ArrowRight']) player.vx = player.speed;
    else player.vx = 0;

    // Jump / Double Jump
    if(keys['Space']){
        if(player.onGround){
            player.vy = -player.jump;
            player.onGround = false;
            audio.jump.play();
            player.doubleJump = true;
        } else if(player.doubleJump){
            player.vy = -player.jump;
            player.doubleJump = false;
            audio.jump.play();
        }
    }

    // Dash
    if(keys['KeyX'] && player.dashCooldown <= 0){
        let dir = (keys['ArrowRight'] ? 1 : (keys['ArrowLeft'] ? -1 : Math.sign(player.vx)));
        player.vx += dir * player.dash;
        player.dashCooldown = 0.5;
        audio.dash.play();
    }
}

// =====================
// PLAYER PHYSICS
// =====================
function updatePlayer(dt){
    player.vy += 50 * dt; // Gravity
    player.x += player.vx;
    player.y += player.vy;

    if(player.dashCooldown > 0) player.dashCooldown -= dt;
    player.onGround = false;

    for(let p of platforms){
        if(player.x + player.w > p.x && player.x < p.x + p.w &&
           player.y + player.h > p.y && player.y + player.h < p.y + p.h + 20 &&
           player.vy >= 0){
            player.y = p.y - player.h;
            player.vy = 0;
            player.onGround = true;
        }
    }

    if(player.y > height + 200) gameOver();
}

// =====================
// CAMERA
// =====================
function updateCamera(){
    camera.x = player.x - width/2;
    camera.y = player.y - height/2;
}

// =====================
// RENDER FUNCTIONS
// =====================
function renderPlatforms(){
    ctx.fillStyle = 'gray';
    for(let p of platforms) ctx.fillRect(p.x,p.y,p.w,p.h);
}
function renderPlayer(){
    ctx.fillStyle = player.shield ? 'cyan' : 'white';
    ctx.fillRect(player.x,player.y,player.w,player.h);
}

// =====================
// BIOMES
// =====================
function initBiomes(){
    biomes = [
        {name:'Neon City', color:'rgba(0,255,255,0.2)'},
        {name:'Lava Hell', color:'rgba(255,50,0,0.2)'},
        {name:'Cyber Desert', color:'rgba(255,255,0,0.2)'},
        {name:'Frozen Void', color:'rgba(0,255,255,0.2)'},
        {name:'Toxic Swamp', color:'rgba(0,150,0,0.2)'},
        {name:'Sky Temple', color:'rgba(255,255,255,0.2)'},
        {name:'Starfield', color:'rgba(200,200,255,0.2)'},
        {name:'Quantum Forest', color:'rgba(100,255,100,0.2)'},
        {name:'Infinity Ruins', color:'rgba(255,100,255,0.2)'},
        {
           // ===== PHẦN 2 =====
// =====================
// GLOBAL VARIABLES (Nâng cấp: Thêm biến cho tutorial, achievements cơ bản, và feedback âm thanh đa dạng để tăng immersion)
// =====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

// Game states (Thêm 'tutorial' và 'ending' để flow tốt hơn)
let gameState = 'menu'; // 'menu', 'playing', 'paused', 'dead', 'shop', 'options', 'leaderboard', 'credits', 'tutorial', 'ending', 'loading'
let keys = {};
let player = {};
let platforms = [];
let enemies = [];
let particles = [];
let biomes = [];
let currentBiome = 0;
let camera = { x: 0, y: 0 };
let upgrades = { speed: 0, jump: 0, dash: 0, shield: false, revive: 0, skin: 0 };
let coins = 0;
let audio = {
    bg: document.getElementById('bgMusic'),
    jump: document.getElementById('jumpSnd'),
    dash: document.getElementById('dashSnd'),
    hit: document.getElementById('hitSnd'),
    boss: document.getElementById('bossSnd'),
    coin: document.getElementById('coinSnd'),
    // Nâng cấp: Thêm âm thanh mới cho feedback đa dạng (landing, enemy death, collectible)
    land: new Audio('land.wav'), // Giả sử bạn có file này, hoặc dùng jump.wav tạm
    enemyDie: new Audio('enemyDie.wav'), // Tương tự
    powerUp: new Audio('powerUp.wav') // Cho collectibles
};
let lastTime = 0;
let bosses = [];
let boss = null;

// New variables for enhanced features (Nâng cấp: Thêm tutorial flag, achievements cơ bản, collectibles)
let settings = { audioEnabled: true, vibrationEnabled: true, difficulty: 'normal' };
let gameStats = { totalDistance: 0, totalCoins: 0, deaths: 0, playTime: 0 };
let isPreloaded = false;
let touchControls = { left: false, jump: false, dash: false };
let leaderboardData = JSON.parse(localStorage.getItem('leaderboard') || '[]');
let saveData = {};
let hasPlayedBefore = localStorage.getItem('hasPlayed') === 'true'; // Flag cho tutorial
let achievements = { firstJump: false, kill10: false }; // Achievements cơ bản để replayability
let enemyKills = 0; // Track kills cho achievements
let collectibles = []; // Mảng cho power-ups tạm thời

// =====================
// PRELOAD ASSETS (Nâng cấp: Thêm preload cho âm thanh mới, và feedback loading)
// =====================
function preloadAssets() {
    return new Promise((resolve) => {
        let loaded = 0;
        const total = Object.keys(audio).length;
        Object.values(audio).forEach(sound => {
            sound.addEventListener('canplaythrough', () => {
                loaded++;
                if (loaded === total) {
                    isPreloaded = true;
                    resolve();
                }
            });
            sound.load();
        });
        // Fallback với feedback (hiển thị loading nếu chậm)
        setTimeout(() => {
            if (!isPreloaded) {
                console.log('Assets loading...'); // Hoặc hiển thị UI loading nếu cần
                isPreloaded = true;
                resolve();
            }
        }, 2000);
    });
}

// =====================
// SAVE/LOAD GAME STATE (Giữ nguyên, nhưng thêm save achievements)
// =====================
function saveGame() {
    saveData = {
        upgrades, coins, gameStats, settings, leaderboardData, achievements, hasPlayedBefore
    };
    localStorage.setItem('parkourSave', JSON.stringify(saveData));
}

function loadGame() {
    const data = JSON.parse(localStorage.getItem('parkourSave') || '{}');
    if (data.upgrades) upgrades = data.upgrades;
    if (data.coins) coins = data.coins;
    if (data.gameStats) gameStats = data.gameStats;
    if (data.settings) settings = data.settings;
    if (data.leaderboardData) leaderboardData = data.leaderboardData;
    if (data.achievements) achievements = data.achievements;
    if (data.hasPlayedBefore !== undefined) hasPlayedBefore = data.hasPlayedBefore;
}

// =====================
// TUTORIAL SYSTEM (Nâng cấp mới: Màn hình tutorial vui vẻ với animations để onboarding tốt)
// =====================
function showTutorial() {
    const tutorialDiv = document.createElement('div');
    tutorialDiv.id = 'tutorialScreen';
    tutorialDiv.className = 'screen';
    tutorialDiv.innerHTML = `
        <div>WELCOME TO PARKOUR ULTIMATE!</div>
        <div id="tutorialStep">Use ARROW KEYS or TOUCH to move and jump.</div>
        <button class="uiButton" id="tutorialBtn" onclick="nextTutorialStep()">NEXT</button>
    `;
    document.getElementById('uiLayer').appendChild(tutorialDiv);
    gameState = 'tutorial';
    let step = 0;
    window.nextTutorialStep = () => {
        step++;
        const steps = [
            'Use ARROW KEYS or TOUCH to move and jump.',
            'Press X or DASH BUTTON for a powerful dash.',
            'Collect coins and avoid enemies to survive!',
            'Buy upgrades in SHOP to get stronger.'
        ];
        if (step < steps.length) {
            document.getElementById('tutorialStep').textContent = steps[step];
        } else {
            closeTutorial();
        }
    };
}

function closeTutorial() {
    document.getElementById('tutorialScreen').remove();
    localStorage.setItem('hasPlayed', 'true');
    hasPlayedBefore = true;
    showMenu();
    saveGame();
}

// =====================
// EVENT LISTENERS (Nâng cấp: Thêm preventDefault tốt hơn, handle touch đa dạng)
// =====================
window.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    e.preventDefault();
    // Track first jump cho achievement
    if (e.code === 'Space' && !achievements.firstJump) {
        achievements.firstJump = true;
        saveGame();
    }
});
window.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    e.preventDefault();
});
window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    if (player.x) {
        camera.x = player.x - width / 2;
        camera.y = player.y - height / 2;
    }
});
window.addEventListener('blur', () => {
    if (gameState === 'playing') {
        gameState = 'paused';
        audio.bg.pause();
    }
});
window.addEventListener('focus', () => {
    if (gameState === 'paused') {
        gameState = 'playing';
        if (settings.audioEnabled) audio.bg.play();
        requestAnimationFrame(loop);
    }
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// =====================
// MOBILE BUTTONS (Nâng cấp: Thêm vibration feedback, prevent multi-touch tốt hơn)
// =====================
function setupMobileControls() {
    const leftBtn = document.getElementById('leftBtn');
    const jumpBtn = document.getElementById('jumpBtn');
    const dashBtn = document.getElementById('dashBtn');

    leftBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchControls.left = true;
        keys['ArrowLeft'] = true;
        if (settings.vibrationEnabled && navigator.vibrate) navigator.vibrate(50);
    });
    leftBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        touchControls.left = false;
        keys['ArrowLeft'] = false;
    });
    jumpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchControls.jump = true;
        keys['Space'] = true;
        if (settings.vibrationEnabled && navigator.vibrate) navigator.vibrate(50);
        if (!achievements.firstJump) {
            achievements.firstJump = true;
            saveGame();
        }
    });
    jumpBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        touchControls.jump = false;
        keys['Space'] = false;
    });
    dashBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchControls.dash = true;
        keys['KeyX'] = true;
        if (settings.vibrationEnabled && navigator.vibrate) navigator.vibrate(50);
    });
    dashBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        touchControls.dash = false;
        keys['KeyX'] = false;
    });
    document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
}

// =====================
// KEY SHORTCUTS (Nâng cấp: Thêm shortcut cho tutorial, achievements view)
// =====================
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyR') restartGame();
    if (e.code === 'KeyM') showMenu();
    if (e.code === 'KeyS') showShop();
    if (e.code === 'KeyO') showOptions();
    if (e.code === 'KeyL') showLeaderboard();
    if (e.code === 'KeyC') showCredits();
    if (e.code === 'KeyT') showTutorial(); // Shortcut để test tutorial
    if (e.code === 'KeyP' && gameState === 'playing') {
        gameState = 'paused';
        audio.bg.pause();
    } else if (e.code === 'KeyP' && gameState === 'paused') {
        gameState = 'playing';
        if (settings.audioEnabled) audio.bg.play();
        requestAnimationFrame(loop);
    }
    if (e.code === 'Escape') showMenu();
});

// =====================
// AUDIO MANAGEMENT (Nâng cấp: Hàm playSound với volume, respect settings, thêm feedback đa dạng)
// =====================
function playSound(sound, volume = 1) {
    if (settings.audioEnabled) {
        sound.volume = volume;
        sound.currentTime = 0;
        sound.play().catch(() => {});
    }
}

function toggleAudio() {
    settings.audioEnabled = !settings.audioEnabled;
    if (settings.audioEnabled) {
        audio.bg.play();
    } else {
        audio.bg.pause();
    }
    saveGame();
}

// =====================
// INITIALIZATION (Nâng cấp: Integrate tutorial vào flow)
// =====================
async function initializeGame() {
    loadGame();
    await preloadAssets();
    setupMobileControls();
    if (!hasPlayedBefore) {
        showTutorial();
    } else {
        showMenu();
    }
}

window.addEventListener('load', initializeGame);

// =====================
// UTILITY FUNCTIONS (Nâng cấp: Thêm updateStats với achievements)
// =====================
function updateStats(dt) {
    if (gameState === 'playing') {
        gameStats.playTime += dt;
        gameStats.totalDistance = Math.max(gameStats.totalDistance, player.x);
        if (enemyKills >= 10) achievements.kill10 = true;
    }
}

function applyDifficulty() {
    switch (settings.difficulty) {
        case 'easy':
            player.speed *= 1.2;
            player.jump *= 1.1;
            break;
        case 'hard':
            player.speed *= 0.8;
            player.jump *= 0.9;
            break;
    }
}

// =====================
// INTEGRATION WITH EXISTING FUNCTIONS (Nâng cấp: Thêm save/load, achievements vào startGame, gameOver)
// =====================
function startGame() {
    document.getElementById('menuScreen').classList.add('hide');
    gameState = 'playing';
    initGame();
    applyDifficulty();
    saveGame();
}

function gameOver() {
    gameStats.deaths++;
    if (upgrades.revive > 0) {
        upgrades.revive--;
        initPlayer();
    } else {
        leaderboardData.push({ score: Math.floor(player.x), time: gameStats.playTime });
        leaderboardData.sort((a, b) => b.score - a.score);
        leaderboardData = leaderboardData.slice(0, 10);
        localStorage.setItem('leaderboard', JSON.stringify(leaderboardData));
        showDeath();
    }
    saveGame();
}

function showLeaderboard() {
    document.getElementById('leaderboardScreen').classList.remove('hide');
    const list = document.getElementById('leaderboardList');
    list.innerHTML = leaderboardData.length ? leaderboardData.map((entry, i) => `${i + 1}. Score: ${entry.score} (Time: ${entry.time.toFixed(1)}s)`).join('<br>') : 'No records yet';
    gameState = 'leaderboard';
}

function showOptions() {
    document.getElementById('optionsScreen').classList.remove('hide');
    gameState = 'options';
}

function closeOptions() {
    document.getElementById('optionsScreen').classList.add('hide');
    gameState = 'menu';
    saveGame();
}

function loop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if (gameState === 'playing') {
        update(dt);
        updateStats(dt);
        render();
        requestAnimationFrame(loop);
    }
}
   // ===== PHẦN 3 =====
// =====================
// PLAYER INIT (Nâng cấp: Thêm stamina, facing, health boost, skin rendering cơ bản)
// =====================
function initPlayer(){
    player = {
        x: width/2, y: height-150,
        w: 50, h: 80,
        vx:0, vy:0,
        speed:5+upgrades.speed,
        jump:15+upgrades.jump,
        dash:20+upgrades.dash,
        onGround:false,
        shield: upgrades.shield,
        dashCooldown:0,
        doubleJump:true,
        health:100,
        maxHealth:100 + (upgrades.health || 0) * 20, // Nâng cấp: Health boost từ shop
        stamina:100,
        maxStamina:100 + (upgrades.stamina || 0) * 20, // Nâng cấp: Stamina boost
        skin: upgrades.skin || 0, // Skin index
        facing: 1, // 1 right, -1 left
        wallJumpAvailable: false,
        animationFrame: 0 // Cho animations cơ bản
    };
}

// =====================
// PLATFORM GENERATION (Nâng cấp: Thêm moving/breaking platforms, spikes, và spawn collectibles ngẫu nhiên để surprise)
// =====================
function generatePlatforms(){
    platforms = [];
    let y = height - 50;
    for(let i=0;i<200;i++){
        let type = Math.random() < 0.1 ? 'moving' : Math.random() < 0.05 ? 'breaking' : 'normal';
        let w = 100 + Math.random()*200;
        let platform = {x:i*250 + Math.random()*100, y:y, w:w, h:20, type:type, active:true};
        if(type === 'moving'){
            platform.vx = (Math.random()-0.5)*2;
            platform.range = 100;
            platform.startX = platform.x;
        }
        platforms.push(platform);
        y -= Math.random()*100 + 50;
        if(y<100) y = height - 50;
    }
    // Add spikes for danger
    for(let i=0;i<50;i++){
        platforms.push({x:Math.random()*50000, y:height-50, w:20, h:20, type:'spike', active:true});
    }
    // Nâng cấp: Spawn collectibles ngẫu nhiên trên platforms
    for(let i=0;i<20;i++){
        if(Math.random() < 0.15){ // 15% chance
            collectibles.push(new Collectible(Math.random()*50000, height - 120, ['speed', 'shield', 'health'][Math.floor(Math.random()*3)]));
        }
    }
}

// =====================
// COLLECTIBLE CLASS (Nâng cấp mới: Power-ups tạm thời để strategy và surprise)
// =====================
class Collectible {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type; this.active = true;
        this.effect = type === 'speed' ? () => { player.speed *= 1.5; setTimeout(() => player.speed /= 1.5, 5000); playSound(audio.powerUp); } :
                     type === 'shield' ? () => { player.shield = true; setTimeout(() => player.shield = false, 10000); playSound(audio.powerUp); } :
                     () => { player.health = Math.min(player.maxHealth, player.health + 20); playSound(audio.coin); };
    }
    update() {
        // Simple gravity for collectibles
        this.y += 1;
        if(this.y > height) this.active = false;
    }
    render() {
        if (!this.active) return;
        ctx.fillStyle = this.type === 'speed' ? 'yellow' : this.type === 'shield' ? 'cyan' : 'green';
        ctx.fillRect(this.x, this.y, 20, 20);
        // Simple glow effect
        ctx.shadowColor = this.type === 'speed' ? 'yellow' : this.type === 'shield' ? 'cyan' : 'green';
        ctx.shadowBlur = 10;
        ctx.fillRect(this.x, this.y, 20, 20);
        ctx.shadowBlur = 0;
    }
}

// =====================
// PLAYER INPUT (Nâng cấp: Thêm wall jump, stamina management, track first jump)
// =====================
function handleInput(){
    // Left / Right movement
    if(keys['ArrowLeft'] || touchControls.left){
        player.vx = -player.speed;
        player.facing = -1;
    } else if(keys['ArrowRight'] || touchControls.right){
        player.vx = player.speed;
        player.facing = 1;
    } else {
        player.vx = 0;
    }

    // Jump / Double Jump / Wall Jump
    if((keys['Space'] || touchControls.jump) && player.stamina > 10){
        if(player.onGround){
            player.vy = -player.jump;
            player.onGround = false;
            playSound(audio.jump);
            player.doubleJump = true;
            player.stamina -= 10;
        } else if(player.doubleJump){
            player.vy = -player.jump;
            player.doubleJump = false;
            playSound(audio.jump);
            player.stamina -= 10;
        } else if(player.wallJumpAvailable){
            player.vy = -player.jump * 0.8;
            player.vx = player.facing * player.speed * 1.5;
            player.wallJumpAvailable = false;
            playSound(audio.jump);
            player.stamina -= 15;
        }
    }

    // Dash
    if((keys['KeyX'] || touchControls.dash) && player.dashCooldown <= 0 && player.stamina > 20){
        let dir = player.facing;
        player.vx += dir * player.dash;
        player.dashCooldown = 0.5;
        playSound(audio.dash);
        player.stamina -= 20;
    }

    // Regenerate stamina
    if(player.onGround) player.stamina = Math.min(player.maxStamina, player.stamina + 50 * (1/60));
}

// =====================
// PLAYER PHYSICS (Nâng cấp: Wall detection, damage từ spikes, better collision, landing sound)
// =====================
function updatePlayer(dt){
    player.vy += 50 * dt;
    player.x += player.vx * dt * 60;
    player.y += player.vy * dt * 60;

    if(player.dashCooldown > 0) player.dashCooldown -= dt;
    player.onGround = false;
    player.wallJumpAvailable = false;

    // Platform collision
    for(let p of platforms){
        if(p.type === 'moving' && p.active){
            p.x += p.vx;
            if(Math.abs(p.x - p.startX) > p.range) p.vx *= -1;
        }
        if(player.x + player.w > p.x && player.x < p.x + p.w &&
           player.y + player.h > p.y && player.y + player.h < p.y + p.h + 20 &&
           player.vy >= 0 && p.active){
            if(p.type === 'breaking'){
                p.active = false;
                // Particles on break
                for(let j=0;j<5;j++) createParticle(p.x + p.w/2, p.y, (Math.random()-0.5)*5, -Math.random()*3, 1, 'orange');
            }
            if(p.type === 'spike'){
                takeDamage(20);
                cameraShake = 0.5;
            } else {
                player.y = p.y - player.h;
                player.vy = 0;
                player.onGround = true;
                if(!player.wasOnGround) playSound(audio.land); // Landing sound
                player.wasOnGround = true;
            }
        }
        // Wall detection
        if(player.vx > 0 && player.x + player.w >= p.x && player.x < p.x && player.y < p.y + p.h && player.y + player.h > p.y && p.active){
            player.wallJumpAvailable = true;
            player.x = p.x - player.w;
        } else if(player.vx < 0 && player.x <= p.x + p.w && player.x + player.w > p.x + p.w && player.y < p.y + p.h && player.y + player.h > p.y && p.active){
            player.wallJumpAvailable = true;
            player.x = p.x + p.w;
        }
    }

    // Remove inactive platforms
    platforms = platforms.filter(p => p.active);

    // Collectible collision
    for(let c of collectibles){
        c.update();
        if(player.x < c.x + 20 && player.x + player.w > c.x && player.y < c.y + 20 && player.y + player.h > c.y){
            c.effect();
            c.active = false;
            // Particles on collect
            for(let j=0;j<3;j++) createParticle(c.x, c.y, (Math.random()-0.5)*3, -Math.random()*2, 1, c.type === 'speed' ? 'yellow' : c.type === 'shield' ? 'cyan' : 'green');
        }
    }
    collectibles = collectibles.filter(c => c.active);

    if(player.y > height + 200) gameOver();
    player.wasOnGround = player.onGround;
    player.animationFrame += dt * 10; // For future animations
}

// =====================
// DAMAGE SYSTEM (Nâng cấp: Hàm takeDamage với screen shake)
// =====================
function takeDamage(amount){
    if(player.shield){
        player.shield = false;
        return;
    }
    player.health -= amount;
    playSound(audio.hit);
    cameraShake = 0.5;
    if(player.health <= 0) gameOver();
}

// =====================
// CAMERA (Nâng cấp: Smooth camera, screen shake on damage)
// =====================
let cameraShake = 0;
function updateCamera(){
    camera.x = player.x - width/2;
    camera.y = player.y - height/2;
    if(cameraShake > 0){
        camera.x += (Math.random()-0.5)*10;
        camera.y += (Math.random()-0.5)*10;
        cameraShake -= 0.1;
    }
}

// =====================
// RENDER FUNCTIONS (Nâng cấp: Skin rendering, platform types, collectibles, simple animations)
// =====================
function renderPlatforms(){
    for(let p of platforms){
        if(p.type === 'spike'){
            ctx.fillStyle = 'red';
            ctx.fillRect(p.x,p.y,p.w,p.h);
        } else {
            ctx.fillStyle = p.type === 'breaking' ? 'orange' : p.type === 'moving' ? 'blue' : 'gray';
            ctx.fillRect(p.x,p.y,p.w,p.h);
        }
    }
}
function renderPlayer(){
    // Skin based on upgrade
    let colors = ['white', 'cyan', 'yellow', 'green', 'purple'];
    ctx.fillStyle = player.shield ? 'cyan' : colors[player.skin % colors.length];
    ctx.fillRect(player.x,player.y,player.w,player.h);
    // Facing direction (simple arrow)
    ctx.fillStyle = 'black';
    ctx.fillRect(player.x + (player.facing > 0 ? player.w - 10 : 0), player.y + 10, 10, 10);
    // Simple animation (blink on jump)
    if(!player.onGround && Math.floor(player.animationFrame) % 2 === 0){
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillRect(player.x,player.y,player.w,player.h);
    }
}

// =====================
// UI RENDER (Nâng cấp: Health, stamina bars, collectible icons)
// =====================
function renderUI(){
    // Health bar
    ctx.fillStyle = 'red';
    ctx.fillRect(10,10,200,20);
    ctx.fillStyle = 'green';
    ctx.fillRect(10,10,(player.health/player.maxHealth)*200,20);
    ctx.strokeStyle = 'white';
    ctx.strokeRect(10,10,200,20);

    // Stamina bar
    ctx.fillStyle = 'gray';
    ctx.fillRect(10,40,200,20);
    ctx.fillStyle = 'blue';
    ctx.fillRect(10,40,(player.stamina/player.maxStamina)*200,20);
    ctx.strokeStyle = 'white';
    ctx.strokeRect(10,40,200,20);

    // Coins
    ctx.fillStyle = 'yellow';
    ctx.font = '20px Press Start 2P';
    ctx.fillText(`Coins: ${coins}`, 10, 80);

    // Achievements indicator
    ctx.fillStyle = 'white';
    ctx.fillText(`Achievements: ${Object.values(achievements).filter(a => a).length}/2`, 10, 110);
}

// =====================
// BIOMES (Nâng cấp: Dynamic effects, background changes, lighting)
// =====================
function initBiomes(){
    biomes = [
        {name:'Neon City', color:'rgba(0,255,255,0.2)', bg:'radial-gradient(circle, #000 0%, #111 100%)', light:'cyan'},
        {name:'Lava Hell', color:'rgba(255,50,0,0.2)', bg:'radial-gradient(circle, #300 0%, #600 100%)', light:'orange'},
        {name:'Cyber Desert', color:'rgba(255,255,0,0.2)', bg:'radial-gradient(circle, #330 0%, #660 100%)', light:'yellow'},
        {name:'Frozen Void', color:'rgba(0,255,255,0.2)', bg:'radial-gradient(circle, #003 0%, #006 100%)', light:'lightblue'},
        {name:'Toxic Swamp', color:'rgba(0,150,0,0.2)', bg:'radial-gradient(circle, #030 0%, #060 100%)', light:'green'},
        {name:'Sky Temple', color:'rgba(255,255,255,0.2)', bg:'radial-gradient(circle, #fff 0%, #ccc 100%)', light:'white'},
        {name:'Starfield', color:'rgba(200,200,255,0.2)', bg:'radial-gradient(circle, #002 0%, #005 100%)', light:'blue'},
        {name:'Quantum Forest', color:'rgba(100,255,100,0.2)', bg:'radial-gradient(circle, #020 0%, #040 100%)', light:'lime'},
        {name:'Infinity Ruins', color:'rgba(255,100,255,0.2)', bg:'radial-gradient(circle, #303 0%, #606 100%)', light:'magenta'},
        {name:'Rainbow Horizon', color:'rgba(255,0,255,0.2)', bg:'radial-gradient(circle, #300 0%, #600 100%)', light:'purple'}
    ];
}

function checkBiome(){
    currentBiome = Math.floor(player.x / 1000) % biomes.length;
    document.getElementById('biomeOverlay').style.background = biomes[currentBiome].color;
    canvas.style.background = biomes[currentBiome].bg;
    // Simple lighting effect
    ctx.globalCompositeOperation = 'overlay';
    ctx.fillStyle = biomes[currentBiome].light;
    ctx.globalAlpha = 0.1;
    ctx.fillRect(0,0,width,height);
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = 'source-over';
}

// =====================
// PARTICLE SYSTEM (Nâng cấp: Pooling for performance, more types)
// =====================
let particlePool = [];
function createParticle(x,y,vx=0,vy=0,life=1,color='white', type='normal'){
    let p = particlePool.pop() || {};
    p.x = x; p.y = y; p.vx = vx; p.vy = vy; p.life = life; p.color = color; p.type = type;
    if(particles.length < 500) particles.push(p);
}
function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
        let p=particles[i];
        p.x += p.vx*dt*60;
        p.y += p.vy*dt*60;
        p.life -= dt;
        if(p.life <= 0){
            particlePool.push(p);
            particles.splice(i,1);
        }
    }
}
function renderParticles(){
    for(let p of particles){
        ctx.fillStyle = p.color;
        if(p.type === 'spark') ctx.fillRect(p.x,p.y,2,10);
        else ctx.fillRect(p.x,p.y,5,5);
    }
}

// =====================
// ENVIRONMENT PARTICLES (Nâng cấp: Biome-specific, more variety)
// =====================
function spawnEnvironmentParticles(){
    switch(biomes[currentBiome].name){
        case 'Neon City':
            for(let i=0;i<3;i++) createParticle(Math.random()*width+camera.x,Math.random()*height+camera.y,0,1,1,'cyan');
            break;
        case 'Lava Hell':
            for(let i=0;i<3;i++) createParticle(Math.random()*width+camera.x,Math.random()*height+camera.y,0,-1,1,'orange');
            if(Math.random()<0.01) createParticle(Math.random()*width+camera.x, height+camera.y, 0, -2, 2, 'red', 'spark');
            break;
        case 'Frozen Void':
            for(let i=0;i<3;i++) createParticle(Math.random()*width+camera.x,Math.random()*height+camera.y,0,1,1,'lightblue');
            break;
        case 'Toxic Swamp':
            for(let i=0;i<3;i++) createParticle(Math.random()*width+camera.x,Math.random()*height+camera.y,0,1,1,'green');
            break;
        case 'Starfield':
            for(let i=0;i<3;i++) createParticle(Math.random()*width+camera.x,Math.random()*height+camera.y,0,0,1,'white');
            break;
        case 'Quantum Forest':
            for(let i=0;i<3;i++) createParticle(Math.random()*width+camera.x,Math.random()*height+camera.y
                                                // ===== PHẦN 4 =====
// =====================
// ENEMIES & BOSS (Nâng cấp: Thêm turret enemies, scaling difficulty, boss phases phức tạp, collision & damage tốt hơn)
// =====================
class Enemy {
    constructor(x, y, type = 'basic') {
        this.x = x;
        this.y = y;
        this.w = 40;
        this.h = 60;
        this.vx = 0;
        this.vy = 0;
        this.type = type;
        this.health = 50;
        this.maxHealth = 50;
        this.active = true;
        this.aiState = 'patrol';
        this.lastAttack = 0;
        this.speed = 2;
        this.detectionRange = 200;
        this.attackRange = 50;
        this.damage = 10;
        this.facing = 1;
        this.counted = false; // For kill tracking
    }

    update(dt) {
        if (!this.active) return;

        this.updateAI(dt);
        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.vy += 50 * dt; // Gravity

        // Platform collision
        for (let p of platforms) {
            if (this.x + this.w > p.x && this.x < p.x + p.w &&
                this.y + this.h > p.y && this.y + this.h < p.y + p.h + 20 &&
                this.vy >= 0 && p.active) {
                this.y = p.y - this.h;
                this.vy = 0;
            }
        }

        if (this.x < camera.x - 100 || this.x > camera.x + width + 100) this.active = false;
    }

    updateAI(dt) {
        const distToPlayer = Math.abs(this.x - player.x);
        if (distToPlayer < this.detectionRange) {
            this.aiState = 'chase';
            this.facing = this.x < player.x ? 1 : -1;
            this.vx = this.facing * this.speed;
        } else {
            this.aiState = 'patrol';
            this.vx = this.facing * this.speed * 0.5;
            if (Math.random() < 0.01) this.facing *= -1;
        }

        if (distToPlayer < this.attackRange && Date.now() - this.lastAttack > 1000) {
            this.attack();
            this.lastAttack = Date.now();
        }
    }

    attack() {
        takeDamage(this.damage);
        cameraShake = 0.5;
        for (let i = 0; i < 5; i++) {
            createParticle(this.x + this.w / 2, this.y + this.h / 2, (Math.random() - 0.5) * 5, -Math.random() * 3, 1, 'red');
        }
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.active = false;
            coins += 5;
            enemyKills++;
            playSound(audio.enemyDie);
            for (let i = 0; i < 10; i++) {
                createParticle(this.x + this.w / 2, this.y + this.h / 2, (Math.random() - 0.5) * 10, -Math.random() * 5, 1, 'orange');
            }
        }
    }

    render() {
        if (!this.active) return;
        ctx.fillStyle = this.type === 'flying' ? 'purple' : this.type === 'turret' ? 'gray' : 'red';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = 'black';
        ctx.fillRect(this.x, this.y - 10, this.w, 5);
        ctx.fillStyle = 'lime';
        ctx.fillRect(this.x, this.y - 10, this.w * (this.health / this.maxHealth), 5);
    }
}

class FlyingEnemy extends Enemy {
    constructor(x, y) {
        super(x, y, 'flying');
        this.speed = 3;
        this.detectionRange = 300;
        this.attackRange = 100;
        this.damage = 15;
        this.vy = 0;
    }

    updateAI(dt) {
        const distToPlayer = Math.sqrt((this.x - player.x) ** 2 + (this.y - player.y) ** 2);
        if (distToPlayer < this.detectionRange) {
            this.aiState = 'chase';
            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
        } else {
            this.aiState = 'patrol';
            this.vx = this.facing * this.speed * 0.5;
            this.vy = Math.sin(Date.now() / 1000) * 2;
        }

        if (distToPlayer < this.attackRange && Date.now() - this.lastAttack > 2000) {
            this.attack();
            this.lastAttack = Date.now();
        }
    }

    attack() {
        projectiles.push({
            x: this.x + this.w / 2,
            y: this.y + this.h / 2,
            vx: (player.x - this.x) / 50,
            vy: (player.y - this.y) / 50,
            life: 5,
            damage: 10
        });
        playSound(audio.hit);
    }
}

class TurretEnemy extends Enemy {
    constructor(x, y) {
        super(x, y, 'turret');
        this.speed = 0;
        this.detectionRange = 300;
        this.attackRange = 250;
        this.damage = 20;
    }

    updateAI(dt) {
        if (Math.abs(this.x - player.x) < this.detectionRange && Date.now() - this.lastAttack > 3000) {
            this.attack();
            this.lastAttack = Date.now();
        }
    }

    attack() {
        projectiles.push({
            x: this.x + this.w / 2,
            y: this.y + this.h / 2,
            vx: (player.x - this.x) / 50,
            vy: (player.y - this.y) / 50,
            life: 5,
            damage: 15
        });
        playSound(audio.hit);
    }
}

// Global projectiles
let projectiles = [];

// =====================
// BOSS CLASS (Nâng cấp: Nhiều phases, attacks đa dạng, rewards sau boss)
// =====================
class Boss {
    constructor(name, x, y, w, h) {
        this.name = name;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.phase = 1;
        this.health = 500;
        this.maxHealth = 500;
        this.rage = false;
        this.projectiles = [];
        this.active = true;
        this.speed = 2;
        this.lastAttack = 0;
        this.attackCooldown = 2000;
        this.facing = 1;
    }

    update(dt) {
        if (!this.active) return;

        if (this.health <= this.maxHealth * 0.6 && this.phase < 2) this.phase = 2;
        if (this.health <= this.maxHealth * 0.3 && this.phase < 3) this.phase = 3;
        if (this.health <= this.maxHealth * 0.1 && !this.rage) {
            this.rage = true;
            this.phase = 4;
            this.speed *= 1.5;
            this.attackCooldown *= 0.5;
        }

        this.updateMovement(dt);
        this.updateAttacks(dt);

        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            let p = this.projectiles[i];
            p.x += p.vx * dt * 60;
            p.y += p.vy * dt * 60;
            p.life -= dt;
            if (p.life <= 0 || p.x < camera.x - 100 || p.x > camera.x + width + 100) {
                this.projectiles.splice(i, 1);
            }
            if (p.x > player.x && p.x < player.x + player.w &&
                p.y > player.y && p.y < player.y + player.h) {
                takeDamage(p.damage || 20);
                this.projectiles.splice(i, 1);
                cameraShake = 0.5;
            }
        }
    }

    updateMovement(dt) {
        if (player.x > this.x) {
            this.x += this.speed;
            this.facing = 1;
        } else {
            this.x -= this.speed;
            this.facing = -1;
        }
        if (this.phase >= 2) {
            this.y = 200 + Math.sin(Date.now() / 1000 * 2) * 100;
        }
    }

    updateAttacks(dt) {
        if (Date.now() - this.lastAttack > this.attackCooldown) {
            switch (this.phase) {
                case 1:
                    this.shootCurved();
                    break;
                case 2:
                    this.groundSmash();
                    break;
                case 3:
                    this.shootHoming();
                    break;
                case 4:
                    this.ultimateAttack();
                    break;
            }
            this.lastAttack = Date.now();
        }
    }

    shootCurved(color = 'cyan', count = 3) {
        for (let i = 0; i < count; i++) {
            this.projectiles.push({
                x: this.x + this.w / 2,
                y: this.y + this.h / 2,
                vx: (Math.random() - 0.5) * 5,
                vy: 3 + Math.random() * 2,
                life: 5,
                color: color,
                damage: 15
            });
        }
    }

    groundSmash() {
        for (let i = 0; i < 10; i++) {
            createParticle(this.x + this.w / 2 + (i - 5) * 20, this.y + this.h, 0, -Math.random() * 3, 1, 'orange');
        }
        if (Math.abs(player.x - this.x) < 100 && player.y > this.y) {
            takeDamage(25);
        }
    }

    shootHoming() {
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        this.projectiles.push({
            x: this.x + this.w / 2,
            y: this.y + this.h / 2,
            vx: Math.cos(angle) * 4,
            vy: Math.sin(angle) * 4,
            life: 5,
            color: 'red',
            damage: 20
        });
    }

    ultimateAttack() {
        for (let i = 0; i < 20; i++) {
            this.projectiles.push({
                x: this.x + this.w / 2,
                y: this.y + this.h / 2,
                vx: (Math.random() - 0.5) * 10,
                vy: Math.random() * 5,
                life: 5,
                color: 'red',
                damage: 25
            });
        }
        cameraShake = 1;
    }

    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.active = false;
            coins += 100;
            playSound(audio.coin);
            // Victory effects
            for (let i = 0; i < 50; i++) {
                createParticle(this.x + this.w / 2, this.y + this.h / 2, (Math.random() - 0.5) * 20, -Math.random() * 10, 2, 'gold');
            }
            // Reward: Unlock next biome or skin
            if (biomes.length > currentBiome + 1) {
                // Placeholder for unlocking
            }
        }
    }

    render() {
        if (!this.active) return;
        ctx.fillStyle = this.rage ? 'darkred' : 'red';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = 'black';
        ctx.fillRect(this.x, this.y - 20, this.w, 10);
        ctx.fillStyle = 'lime';
        ctx.fillRect(this.x, this.y - 20, this.w * (this.health / this.maxHealth), 10);
        for (let p of this.projectiles) {
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 10, 10);
        }
    }
}

// =====================
// INITIALIZE BOSSES & ENEMIES (Nâng cấp: Scaling spawn based on distance)
// =====================
bosses = [
    new Boss('Shadow Orb', width + 200, 200, 80, 80),
    new Boss('Titan Runner', width + 400, height - 150, 100, 120),
    new Boss('Sky Serpent', width + 600, 150, 120, 60)
];

function spawnEnemies() {
    enemies = [];
    const enemyCount = Math.min(15, 5 + Math.floor(player.x / 1000)); // Scale with progress
    for (let i = 0; i < enemyCount; i++) {
        const x = Math.random() * 2000 + player.x + 500;
        const y = height - 100;
        const type = Math.random() < 0.2 ? 'flying' : Math.random() < 0.4 ? 'turret' : 'basic';
        if (type === 'flying') enemies.push(new FlyingEnemy(x, y - 50));
        else if (type === 'turret') enemies.push(new TurretEnemy(x, y));
        else enemies.push(new Enemy(x, y));
    }
}

function updateEnemies(dt) {
    for (let i = enemies.length - 1; i >= 0; i--) {
        enemies[i].update(dt);
        if (!enemies[i].active) {
            if (!enemies[i].counted) {
                enemyKills++;
                enemies[i].counted = true;
            }
            enemies.splice(i, 1);
        }
    }
    // Collision with player
    for (let e of enemies) {
        if (e.x < player.x + player.w && e.x + e.w > player.x &&
            e.y < player.y + player.h && e.y + e.h > player.y) {
            takeDamage(e.damage);
            e.takeDamage(50);
        }
    }
}

function updateBoss(dt) {
    if (!boss && player.x > 1000) boss = bosses[0];
    if (boss) boss.update(dt);
}

function renderEnemies() {
    for (let e of enemies) e.render();
    if (boss) boss.render();
    for (let p of projectiles) {
        ctx.fillStyle = p.color || 'white';
        ctx.fillRect(p.x, p.y, 10, 10);
    }
}
          // ===== PHẦN 5 =====
// =====================
// SHOP & UPGRADES (Nâng cấp: UI động, descriptions, inventory, power-ups)
// =====================
let shopItems = [
    { id: 'speed', name: 'Speed Boost', desc: 'Increase movement speed', cost: 50, max: 10 },
    { id: 'jump', name: 'Jump Power', desc: 'Higher jumps', cost: 50, max: 10 },
    { id: 'dash', name: 'Dash Force', desc: 'Stronger dashes', cost: 100, max: 5 },
    { id: 'shield', name: 'Energy Shield', desc: 'Absorbs one hit', cost: 200, max: 1 },
    { id: 'revive', name: 'Extra Life', desc: 'Revive on death', cost: 300, max: 3 },
    { id: 'skin', name: 'Skin Unlock', desc: 'New appearance', cost: 150, max: 5 },
    { id: 'health', name: 'Health Boost', desc: 'Increase max health', cost: 250, max: 5 },
    { id: 'stamina', name: 'Stamina Boost', desc: 'Increase max stamina', cost: 250, max: 5 }
];

function buyUpgrade(type) {
    const item = shopItems.find(i => i.id === type);
    if (!item || upgrades[type] >= item.max || coins < item.cost) return;
    coins -= item.cost;
    upgrades[type]++;
    if (type === 'health') player.maxHealth += 20;
    if (type === 'stamina') player.maxStamina += 20;
    playSound(audio.coin);
    updateShopUI();
    saveGame();
}

function updateShopUI() {
    const shopDiv = document.getElementById('shopScreen');
    shopDiv.innerHTML = '<div>SHOP</div>';
    shopItems.forEach(item => {
        const owned = upgrades[item.id] || 0;
        const canBuy = owned < item.max && coins >= item.cost;
        const btn = document.createElement('button');
        btn.className = 'uiButton';
        btn.textContent = `${item.name} (${owned}/${item.max}) - ${item.cost} Coins`;
        btn.title = item.desc;
        btn.onclick = () => buyUpgrade(item.id);
        if (!canBuy) btn.disabled = true;
        shopDiv.appendChild(btn);
    });
    const backBtn = document.createElement('button');
    backBtn.className = 'uiButton';
    backBtn.textContent = 'BACK';
    backBtn.onclick = closeShop;
    shopDiv.appendChild(backBtn);
}

function closeShop() {
    document.getElementById('shopScreen').classList.add('hide');
    gameState = 'playing';
}

// =====================
// OPTIONS (Nâng cấp: UI động cho settings, difficulty, vibration, audio)
// =====================
function showOptions() {
    document.getElementById('optionsScreen').classList.remove('hide');
    updateOptionsUI();
    gameState = 'options';
}

function updateOptionsUI() {
    const optionsDiv = document.getElementById('optionsScreen');
    optionsDiv.innerHTML = '<div>OPTIONS</div>';
    
    // Audio Toggle
    const audioBtn = document.createElement('button');
    audioBtn.className = 'uiButton';
    audioBtn.textContent = `TOGGLE MUSIC (${settings.audioEnabled ? 'ON' : 'OFF'})`;
    audioBtn.onclick = toggleAudio;
    optionsDiv.appendChild(audioBtn);
    
    // Vibration Toggle
    const vibBtn = document.createElement('button');
    vibBtn.className = 'uiButton';
    vibBtn.textContent = `VIBRATION (${settings.vibrationEnabled ? 'ON' : 'OFF'})`;
    vibBtn.onclick = () => { settings.vibrationEnabled = !settings.vibrationEnabled; updateOptionsUI(); saveGame(); };
    optionsDiv.appendChild(vibBtn);
    
    // Difficulty
    const diffBtn = document.createElement('button');
    diffBtn.className = 'uiButton';
    diffBtn.textContent = `DIFFICULTY: ${settings.difficulty.toUpperCase()}`;
    diffBtn.onclick = () => {
        const diffs = ['easy', 'normal', 'hard'];
        const currentIndex = diffs.indexOf(settings.difficulty);
        settings.difficulty = diffs[(currentIndex + 1) % diffs.length];
        updateOptionsUI();
        saveGame();
    };
    optionsDiv.appendChild(diffBtn);
    
    // Back
    const backBtn = document.createElement('button');
    backBtn.className = 'uiButton';
    backBtn.textContent = 'BACK';
    backBtn.onclick = closeOptions;
    optionsDiv.appendChild(backBtn);
}

function closeOptions() {
    document.getElementById('optionsScreen').classList.add('hide');
    gameState = 'menu';
    saveGame();
}

// =====================
// LEADERBOARD (Nâng cấp: Sorting, time display, achievements)
// =====================
function showLeaderboard() {
    document.getElementById('leaderboardScreen').classList.remove('hide');
    updateLeaderboardUI();
    gameState = 'leaderboard';
}

function updateLeaderboardUI() {
    const list = document.getElementById('leaderboardList');
    leaderboardData.sort((a, b) => b.score - a.score);
    list.innerHTML = leaderboardData.length ? leaderboardData.slice(0, 10).map((entry, i) => 
        `${i + 1}. Score: ${entry.score} | Time: ${entry.time.toFixed(1)}s | Biome: ${biomes[Math.floor(entry.score / 1000) % biomes.length].name}`
    ).join('<br>') : 'No records yet';
}

function closeLeaderboard() {
    document.getElementById('leaderboardScreen').classList.add('hide');
    gameState = 'menu';
}

// =====================
// CREDITS (Nâng cấp: Thêm contributors, links)
// =====================
function showCredits() {
    document.getElementById('creditsScreen').classList.remove('hide');
    gameState = 'credits';
}

function closeCredits() {
    document.getElementById('creditsScreen').classList.add('hide');
    gameState = 'menu';
}

// =====================
// DEATH & MENU SCREENS (Nâng cấp: Stats display, achievements)
// =====================
function showDeath() {
    document.getElementById('deathScreen').classList.remove('hide');
    const deathDiv = document.getElementById('deathScreen');
    deathDiv.innerHTML = `
        <div>YOU DIED</div>
        <div>Score: ${Math.floor(player.x)}</div>
        <div>Coins Collected: ${gameStats.totalCoins}</div>
        <div>Time Survived: ${gameStats.playTime.toFixed(1)}s</div>
        <div>Enemies Killed: ${enemyKills}</div>
        <button class="uiButton" onclick="restartGame()">RETRY</button>
        <button class="uiButton" onclick="showMenu()">MENU</button>
    `;
    gameState = 'dead';
}

function showMenu() {
    document.getElementById('menuScreen').classList.remove('hide');
    document.getElementById('deathScreen').classList.add('hide');
    document.getElementById('shopScreen').classList.add('hide');
    document.getElementById('optionsScreen').classList.add('hide');
    document.getElementById('leaderboardScreen').classList.add('hide');
    document.getElementById('creditsScreen').classList.add('hide');
    document.getElementById('bossIntro').classList.add('hide');
    gameState = 'menu';
}

// =====================
// GAME INIT (Nâng cấp: Loading screen, preload check)
// =====================
function initGame() {
    if (!isPreloaded) {
        gameState = 'loading';
        setTimeout(initGame, 500);
        return;
    }
    initPlayer();
    generatePlatforms();
    initBiomes();
    spawnEnemies();
    lastTime = performance.now();
    gameState = 'playing';
    playSound(audio.bg);
    requestAnimationFrame(loop);
}

// =====================
// PLAYER INPUT (MOBILE) (Nâng cấp: Touch controls for all buttons)
// =====================
function setupMobileControls() {
    // Already in part 2, but ensure all are set
    // Add rightBtn if needed, but for now, dash as right
    touchControls.right = false;
    const rightBtn = document.createElement('div');
    rightBtn.id = 'rightBtn';
    rightBtn.className = 'mobileBtn';
    rightBtn.textContent = '▶';
    document.getElementById('mobileControls').appendChild(rightBtn);
    rightBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touchControls.right = true;
        keys['ArrowRight'] = true;
        if (settings.vibrationEnabled && navigator.vibrate) navigator.vibrate(50);
    });
    rightBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        touchControls.right = false;
        keys['ArrowRight'] = false;
    });
}

// =====================
// KEY SHORTCUTS (Nâng cấp: More shortcuts, pause menu)
// =====================
window.addEventListener('keydown', (e) => {
    if (e.code === 'KeyR') restartGame();
    if (e.code === 'KeyM') showMenu();
    if (e.code === 'KeyS') showShop();
    if (e.code === 'KeyO') showOptions();
    if (e.code === 'KeyL') showLeaderboard();
    if (e.code === 'KeyC') showCredits();
    if (e.code === 'KeyP' && gameState === 'playing') {
        gameState = 'paused';
        audio.bg.pause();
    } else if (e.code === 'KeyP' && gameState === 'paused') {
        gameState = 'playing';
        if (settings.audioEnabled) audio.bg.play();
        requestAnimationFrame(loop);
    }
    if (e.code === 'Escape') showMenu();
});

// =====================
// AUDIO TOGGLE (Nâng cấp: Already in part 2)
// =====================

// =====================
// GAME LOOP (Nâng cấp: Pause handling, stats update)
// =====================
function loop(timestamp) {
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    if (gameState === 'playing') {
        update(dt);
        updateStats(dt);
        render();
        requestAnimationFrame(loop);
    } else if (gameState === 'paused') {
        renderPause();
    }
}

// =====================
// UPDATE FUNCTION (Nâng cấp: Integrate all systems)
// =====================
function update(dt) {
    handleInput();
    updatePlayer(dt);
    updateCamera();
    updateParticles(dt);
    spawnEnvironmentParticles();
    checkBiome();
    updateEnemies(dt);
    updateBoss(dt);
    // Update projectiles if any global
}

// =====================
// RENDER FUNCTION (Nâng cấp: UI overlays, effects)
// =====================
function render() {
    ctx.clearRect(0, 0, width, height);
    ctx.save();
    ctx.translate(-camera.x, -camera.y);
    renderPlatforms();
    renderPlayer();
    renderParticles();
    renderEnemies();
    ctx.restore();
    renderUI();
}

function renderPause() {
    render(); // Render game in background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = 'white';
    ctx.font = '30px Press Start 2P';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', width / 2, height / 2);
    ctx.font = '16px Press Start 2P';
    ctx.fillText('Press P to Resume', width / 2, height / 2 + 50);
}

// =====================
// SPAWN ENVIRONMENT PARTICLES (Nâng cấp: Already optimized)
// =====================

// =====================
// SPAWN PLAYER MOTION TRAIL (Nâng cấp: Already in part 3)
// =====================

// =====================
// INITIAL MENU (Nâng cấp: With loading check)
// =====================
async function initializeGame() {
    loadGame();
    await preloadAssets();
    setupMobileControls();
    if (!hasPlayedBefore) {
        showTutorial();
    } else {
        showMenu();
    }
}

// Call on load
window.addEventListener('load', initializeGame);
